Nous savons par expérience qu'il est difficile d'avoir toutes nos fonctions dans le même fichier et la même portée.

Dans cette leçon, nous allons couvrir comment regrouper les fonctions et définir une carte spécialisée connue sous le nom de struct afin d'organiser notre code plus efficacement.

## Modules

Les modules nous permettent d'organiser les fonctions dans un espace de nom.
En plus de regrouper les fonctions, ils nous permettent de définir des fonctions nommées et privées que nous avons abordées dans la [leçon sur les fonctions](/fr/lessons/basics/functions).

Voyons un exemple de base :

```elixir
defmodule Exemple do
  def greeting(name) do
    "Bonjour #{nom}."
  end
end

iex> Exemple.greeting "Sean"
"Bonjour Sean."
```

Il est possible d'imbriquer des modules dans Elixir, ce qui vous permet d'espacer davantage vos fonctionnalités :

```elixir
defmodule Exemple.salutations do
  def morning(name) do
    "Bonjour #{nom}."
  end

  def soir(nom) do
    "Bonne nuit #{nom}."
  end
end

iex> Exemple.Greetings.morning "Sean"
"Bonjour Sean."
```

### Attributs de module

Les attributs de module sont le plus souvent utilisés comme des constantes en Elixir.
Voyons un exemple simple :

```elixir
defmodule Exemple do
  @greeting "Bonjour"

  def greeting(name) do
    ~s(#{@greeting} #{name}.)
  end
end
```

Il est important de noter qu'il existe des attributs réservés dans Elixir.
Les trois plus courants sont :

- `moduledoc` - Documente le module courant.
- `doc` - Documentation des fonctions et des macros.
- `behaviour` - Utilise un comportement OTP ou défini par l'utilisateur.

## Structs

Les structures sont des cartes spéciales avec un ensemble défini de clés et de valeurs par défaut.
Une structure doit être définie dans un module, dont elle prend le nom.
Il est courant qu'une structure soit la seule chose définie dans un module.

Pour définir une structure, on utilise `defstruct` avec une liste de champs et de valeurs par défaut :

```elixir
defmodule Exemple.Utilisateur do
  defstruct nom : "Sean", roles : []
end
```

Créons quelques structures :

```elixir
iex> %Example.User{}
%Example.User<name : "Sean", roles : [], ...>

iex> %Example.User{name : "Steve"}
%Example.User<name : "Steve", roles : [], ...>

iex> %Example.User{name : "Steve", roles : [:manager]}
%Example.User<name : "Steve", roles : [:manager]>
```

Nous pouvons mettre à jour notre structure comme nous le ferions avec une carte :

```elixir
iex> steve = %Example.User{name : "Steve"}
%Example.User<name : "Steve", roles : [...], ...>
iex> sean = %{steve | nom : "Sean"}
%Example.User<name : "Sean", roles : [...], ...>
```

Plus important encore, vous pouvez faire correspondre des structs avec des maps :

```elixir
iex> %{name : "Sean"} = sean
%Example.User<name : "Sean", roles : [...], ...>
```

Depuis Elixir 1.8, les structures incluent une introspection personnalisée.
Pour comprendre ce que cela signifie et comment nous devons l'utiliser, inspectons notre capture `sean` :

```elixir
iex> inspect(sean)
"%Exemple.Utilisateur<nom : \"Sean\", roles : [...], ...>"
```

Tous nos champs sont présents, ce qui est correct pour cet exemple, mais que faire si nous avons un champ protégé que nous ne voulons pas inclure ?
La nouvelle fonctionnalité `@derive` nous permet de faire exactement cela !
Mettons à jour notre exemple pour que `roles` ne soient plus inclus dans notre sortie :

```elixir
defmodule Exemple.Utilisateur faire
  @derive {Inspect, seulement : [:name]}
  defstruct nom : nil, rôles : []
end
```

Remarque : nous pourrions également utiliser `@derive {Inspect, except : [:roles]}`, ils sont équivalents.

Avec notre module mis à jour en place, regardons ce qui se passe dans `iex` :

```elixir
iex> sean = %Example.User{name : "Sean"}
%Exemple.User<name : "Sean", ...>
iex> inspect(sean)
"%Example.User<name : \"Sean\", ...>"
```

Les `roles` sont exclus de la sortie !

## Composition

Maintenant que nous savons comment créer des modules et des structs, apprenons à leur ajouter des fonctionnalités existantes via la composition.
Elixir nous fournit une variété de moyens différents pour interagir avec d'autres modules.

### alias

Nous permet d'aliaser les noms de modules ; utilisé assez fréquemment dans le code Elixir :

```elixir
defmodule Sayings.Greetings do
  def basic(nom), do : "Salut, #{nom}"
end

defmodule Exemple do
  alias Sayings.Greetings

  def salutations(nom), do : salutations.basique(nom)
end

# Sans alias

defmodule Exemple do
  def salutation(nom), do : Sayings.Greetings.basic(nom)
end
```

S'il y a un conflit entre deux alias ou si l'on souhaite simplement aliaser vers un nom différent, on peut utiliser l'option `:as` :

```elixir
defmodule Exemple do
  alias Sayings.Greetings, as : Bonjour

  def print_message(name), do : Hi.basic(nom)
end
```

Il est même possible d'aliaser plusieurs modules à la fois :

```elixir
defmodule Exemple do
  alias Dictons.{Bonsoir, Adieux}
end
```

### import

Si nous voulons importer des fonctions plutôt que d'aliaser le module, nous pouvons utiliser `import` :

```elixir
iex> last([1, 2, 3])
** (CompileError) iex:9 : fonction indéfinie last/1
iex> import Liste
nil
iex> last([1, 2, 3])
3
```

#### Filtrage

Par défaut, toutes les fonctions et macros sont importées mais nous pouvons les filtrer en utilisant les options `:only` et `:except`.

Pour importer des fonctions et des macros spécifiques, nous devons fournir les paires nom/caractère à `:only` et `:except`.
Commençons par importer uniquement la fonction `last/1` :

```elixir
iex> import Liste, only : [last : 1]
iex> first([1, 2, 3])
** (CompileError) iex:13 : fonction indéfinie first/1
iex> last([1, 2, 3])
3
```

Si nous importons tout sauf `last/1` et essayons les mêmes fonctions que précédemment :

```elixir
iex> import List, except : [last : 1]
nil
iex> first([1, 2, 3])
1
iex> last([1, 2, 3])
** (CompileError) iex:3 : fonction indéfinie last/1
```

En plus des paires nom/arité, il existe deux atomes spéciaux, `:functions` et `:macros`, qui n'importent respectivement que des fonctions et des macros :

```elixir
import List, only : :functions
import List, only : :macros
```

### require

Nous pouvons utiliser `require` pour indiquer à Elixir que vous allez utiliser des macros d'un autre module.
La légère différence avec `import` est qu'il permet d'utiliser les macros, mais pas les fonctions du module spécifié :

```elixir
defmodule Exemple do
  nécessite SuperMacros

  SuperMacros.do_stuff
end
```

Si nous essayons d'appeler une macro qui n'est pas encore chargée, Elixir lèvera une erreur.

### use

Avec la macro `use`, nous pouvons permettre à un autre module de modifier la définition de notre module actuel.
Lorsque nous appelons `use` dans notre code, nous invoquons en fait le callback `__using__/1` défini par le module fourni.
Le résultat de la macro `__using__/1` devient une partie de la définition de notre module.
Pour mieux comprendre comment cela fonctionne, prenons un exemple simple :

```elixir
defmodule Hello do
  defmacro __using__(_opts) do
    quote do
      def hello(nom), do : "Salut, #{nom}"
    end
  end
end
```

Ici, nous avons créé un module `Hello` qui définit le callback `__using__/1` à l'intérieur duquel nous définissons une fonction `hello/1`.
Créons un nouveau module pour tester notre nouveau code :

```elixir
defmodule Exemple do
  utiliser Hello
end
```

Si nous essayons notre code dans Ex, nous verrons que `hello/1` est disponible sur le module `Example` :

```elixir
iex> Exemple.hello("Sean")
"Salut, Sean"
```

Ici, nous pouvons voir que `use` a invoqué le callback `__using__/1` sur `Hello` qui, à son tour, a ajouté le code résultant à notre module.
Maintenant que nous avons montré un exemple de base, mettons à jour notre code pour voir comment `__using__/1` supporte les options.
Nous allons le faire en ajoutant une option `greeting` :

```elixir
defmodule Bonjour faire
  defmacro __using__(opts) do
    greeting = Keyword.get(opts, :greeting, "Salut")

    quote do
      def hello(name), do : unquote(greeting) <> ", " <> name
    end
  end
end
```

Mettons à jour notre module `Example` pour inclure l'option `greeting` nouvellement créée :

```elixir
defmodule Exemple do
  utiliser Hello, greeting : "Hola"
end
```

Si nous faisons un essai en IEx, nous verrons que le message d'accueil a été modifié :

```elixir
iex> Exemple.hello("Sean")
"Hola, Sean"
```

Il s'agit d'exemples simples pour démontrer le fonctionnement de `use` mais c'est un outil incroyablement puissant dans la boîte à outils d'Elixir.
Au fur et à mesure de votre apprentissage d'Elixir, gardez un œil sur les `use`, un exemple que vous ne manquerez pas de voir est `use ExUnit.Case, async : true`.

**Note** : `quote`, `alias`, `use`, `require` sont des macros liées à la [métaprogrammation](/fr/lessons/advanced/metaprogramming).
