Dans cette leçon, nous allons examiner les structures de contrôle à notre disposition dans Elixir.

## if et unless

Il y a de fortes chances que vous ayez déjà rencontré `if/2`, et si vous avez utilisé Ruby, vous êtes familier avec `unless/2`.
En Elixir, ils fonctionnent à peu près de la même manière, mais ils sont définis comme des macros, et non comme des constructions de langage. Vous pouvez trouver leur implémentation dans le module [Kernel] (https://hexdocs.pm/elixir/Kernel.html).

Il est à noter qu'en Elixir, les seules valeurs fausses sont `nil` et le booléen `false`.

```elixir
iex> if String.valid ?("Hello") do
...> "Chaîne valide !"
...> else
...> "Chaîne de caractères non valide".
...> end
"Chaîne valide !"

iex> if "a string value" do
...> "Truthy"
...> end
"Truthy"
```

L'utilisation de `unless/2` est comme `if/2` sauf qu'elle fonctionne sur la négative :

```elixir
iex> unless is_integer("hello") do
...> "Pas un Int"
...> end
"Pas un Int"
```

## case

S'il est nécessaire d'effectuer une correspondance avec plusieurs motifs, nous pouvons utiliser `case/2` :

```elixir
iex> case {:ok, "Hello World"} do
...> {:ok, résultat} -> résultat
...> {:error} -> "Uh oh !"
...> _ -> "Catch all" (attrape tout)
...> end
"Hello World"
```

La variable `_` est une inclusion importante dans les instructions `case/2`. Sans elle, l'impossibilité de trouver une correspondance entraînera une erreur :

```elixir
iex> case :even do
...> :odd -> "Odd" (impaire)
...> end
** (CaseClauseError) Pas de correspondance avec la clause case : :even

iex> case :even do
...> :odd -> "Odd" (impaire)
...> _ -> "Not Odd" (pas impair)
...> end
"Pas impaire"
```

Considérez `_` comme le `else` qui correspondra à "tout le reste".

Puisque `case/2` s'appuie sur la correspondance de motifs, toutes les mêmes règles et restrictions s'appliquent.
Si vous avez l'intention de faire correspondre des variables existantes, vous devez utiliser l'opérateur `^/1` :

```elixir
iex> pie = 3.14
 3.14
iex> case "cherry pie" do
...> ^tarte -> "Pas si bon que ça".
...> pie -> "Je parie que #{pie} est savoureuse".
...> end
"Je parie que la tarte aux cerises est savoureuse"
```

Une autre caractéristique intéressante de `case/2` est son support des clauses de garde :

Cet exemple provient directement du guide officiel Elixir [Getting Started](https://elixir-lang.org/getting-started/case-cond-and-if.html#case).

```elixir
iex> case {1, 2, 3} do
...> {1, x, 3} when x > 0 ->
...> "Will match" (correspondra)
...> _ ->
...> "Ne correspondra pas".
...> end
"Correspondra" ...> _ -> ...> "Ne correspondra pas" ...> end
```

Consultez la documentation officielle sur les [Expressions autorisées dans les clauses de garde] (https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions).

## cond

Lorsque nous avons besoin de faire correspondre des conditions plutôt que des valeurs, nous pouvons nous tourner vers `cond/1` ; cela ressemble à `else if` ou `elsif` dans d'autres langues :

Cet exemple est tiré directement du guide officiel Elixir [Getting Started](https://elixir-lang.org/getting-started/case-cond-and-if.html#cond).

```Elixir
iex> cond do
...> 2 + 2 == 5 ->
...> "Ce ne sera pas vrai".
...> 2 * 2 == 3 ->
...> "Ni ceci"
...> 1 + 1 == 2 ->
...> "Mais ceci sera vrai"
...> fin
"Mais cela va"
```

Comme `case/2`, `cond/1` lèvera une erreur s'il n'y a pas de correspondance.
Pour gérer cela, nous pouvons définir une condition définie sur `true` :

```elixir
iex> cond do
...> 7 + 1 == 0 -> " Incorrect ".
...> true -> "Catch all" (attrape tout)
...> end
"Attraper tout"
```

## with

La forme spéciale `with/1` est utile lorsque vous risquez d'utiliser une instruction `case/2` imbriquée ou des situations qui ne peuvent pas être proprement enchaînées. L'expression `with/1` est composée des mots-clés, des générateurs, et enfin d'une expression.

Nous parlerons plus en détail des générateurs dans la [leçon sur les compréhensions de listes](/fr/lessons/basics/comprehensions), mais pour l'instant, il suffit de savoir qu'ils utilisent la [correspondance de motifs](/fr/lessons/basics/pattern_matching) pour comparer le côté droit du `<-` au côté gauche.

Nous commencerons par un exemple simple de `with/1`, puis nous verrons quelque chose de plus :

```elixir
iex> user = %{first : "Sean", last : "Callan"}
%{first : "Sean", last : "Callan"}
iex> avec {:ok, first} <- Map.fetch(user, :first),
...> {:ok, last} <- Map.fetch(user, :last),
...> do : last <> ", " <> first
"Callan, Sean"
```

En cas d'échec de la correspondance d'une expression, la valeur non correspondante sera retournée :

```elixir
iex> user = %{first : "doomspork"}
%{first : "doomspork"}
iex> avec {:ok, first} <- Map.fetch(user, :first),
...> {:ok, last} <- Map.fetch(user, :last),
...> do : last <> ", " <> first
:error
```

Maintenant, regardons un exemple plus large sans `with/1` et voyons ensuite comment nous pouvons le refactorer :

```elixir
case Repo.insert(changeset) do
  {:ok, utilisateur} ->
    case Guardian.encode_and_sign(user, :token, claims) do
      {:ok, jeton, réclamations_intégrales} ->
        important_stuff(token, full_claims)

      erreur ->
        erreur
    fin

  erreur ->
    erreur
end
```

Lorsque nous introduisons `with/1`, nous obtenons un code facile à comprendre et comportant moins de lignes :

```elixir
avec {:ok, utilisateur} <- Repo.insert(changeset),
     {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
  important_stuff(token, full_claims)
end
```


Depuis Elixir 1.3, les instructions `with/1` supportent `else` :

```elixir
import Integer

m = %{a : 1, c : 3}

a =
  avec {:ok, nombre} <- Map.fetch(m, :a),
    true <- is_even(number) do
      IO.puts "#{nombre} divisé par 2 est #{div(nombre, 2)}"
      :even
  else
    :error ->
      IO.puts("Nous n'avons pas cet élément dans la carte")
      :error

    _ ->
      IO.puts("C'est bizarre")
      :odd
  fin
```

Il aide à gérer les erreurs en fournissant une correspondance de motifs de type `case`. La valeur passée est la première expression qui ne correspond pas.
