Avant de pouvoir plonger dans les eaux plus profondes d'Elixir, nous devons d'abord apprendre à connaître Mix.
Si vous êtes familier avec Ruby, Mix est la combinaison de Bundler, RubyGems et Rake.
C'est un élément crucial de tout projet Elixir et, dans cette leçon, nous allons explorer quelques-unes de ses grandes fonctionnalités.
Pour voir tout ce que Mix a à offrir dans l'environnement actuel, lancez `mix help`.

Jusqu'à présent, nous avons travaillé exclusivement avec `iex` qui a ses limites.
Afin de construire quelque chose de substantiel, nous devons diviser notre code en plusieurs fichiers pour le gérer efficacement ; Mix nous permet de le faire avec des projets.

## Nouveaux projets

Lorsque nous sommes prêts à créer un nouveau projet Elixir, Mix nous facilite la tâche avec la commande `mix new`.
Cela va générer la structure des dossiers de notre projet et le boilerplate nécessaire.
C'est assez simple, alors commençons :

```bash
$ mix new example
```

A partir de la sortie, nous pouvons voir que Mix a créé notre répertoire et un certain nombre de fichiers passe-partout :

```bash
* Création du fichier README.md
* Création du fichier .formatter.exs
* création de .gitignore
* création de mix.exs
* création de lib
* Création de lib/example.ex
* creating test
* création de test/test_helper.exs
creating test/example_test.exs * creating test/example_test.exs
```

Dans cette leçon, nous allons concentrer notre attention sur `mix.exs`.
Ici, nous configurons notre application, nos dépendances, notre environnement et notre version.
Ouvrez le fichier dans votre éditeur préféré, vous devriez voir quelque chose comme ceci (commentaires enlevés pour la brièveté) :

```elixir
defmodule Exemple.MixProject do
  utiliser Mix.Project

  def project do
    [
      app : :exemple,
      version : "0.1.0",
      élixir : "~> 1.5",
      start_permanent : Mix.env() == :prod,
      deps : deps()
    ]
  end

  def application do
    [
      extra_applications : [:logger]
    ]
  end

  defp deps do
    []
  end
end
```

La première section que nous allons regarder est `project`.
Ici, nous définissons le nom de notre application (`app`), nous spécifions notre version (`version`), la version d'Elixir (`elixir`), et enfin nos dépendances (`deps`).

La section `application` est utilisée pendant la génération de notre fichier d'application que nous couvrirons ensuite.

## Interactive

Il peut être nécessaire d'utiliser `iex` dans le contexte de notre application.
Heureusement pour nous, Mix rend cela facile.
Nous pouvons démarrer une nouvelle session `iex` :

```bash
$ cd exemple
$ iex -S mix
```

En démarrant `iex` de cette manière, votre application et ses dépendances seront chargées dans le runtime actuel.

## Compilation

Mix est intelligent et compilera vos changements quand cela est nécessaire, mais il peut être nécessaire de compiler explicitement votre projet.
Dans cette section, nous allons voir comment compiler notre projet et ce que fait la compilation.

Pour compiler un projet Mix, il suffit d'exécuter `mix compile` dans notre répertoire de base :
**Note : Les tâches Mix pour un projet ne sont disponibles qu'à partir du répertoire racine du projet, seules les tâches Mix globales sont disponibles autrement.**

```bash
$ mix compile
```

Il n'y a pas grand chose dans notre projet donc la sortie n'est pas très excitante mais elle devrait se terminer avec succès :

```bash
Compilé lib/example.ex
Application d'exemple générée
```

Lorsque nous compilons un projet, Mix crée un répertoire `_build` pour nos artefacts.
Si nous regardons dans `_build`, nous verrons notre application compilée : `example.app`.

## Gérer les dépendances

Notre projet n'a pas de dépendances, mais il en aura bientôt, donc nous allons continuer et couvrir la définition des dépendances et leur récupération.

Pour ajouter une nouvelle dépendance, nous devons d'abord l'ajouter à notre `mix.exs` dans la section `deps`.
Notre liste de dépendances est composée de tuples avec deux valeurs obligatoires et une optionnelle : le nom du paquet en tant qu'atome, la chaîne de version, et les options facultatives.

Pour cet exemple, regardons un projet avec des dépendances, comme [phoenix_slim](https://github.com/doomspork/phoenix_slim) :

```elixir
def deps do
  [
    {:phoenix, "~> 1.1 ou ~> 1.2"},
    {:phoenix_html, "~> 2.3"},
    {:cowboy, "~> 1.0", seulement : [:dev, :test]},
    {:slime, "~> 0.14"}, {:slime, "~> 0.14"}
  ]
end
```

Comme vous l'avez probablement remarqué dans les dépendances ci-dessus, la dépendance `cowboy` n'est nécessaire que pendant le développement et le test.

Une fois que nous avons défini nos dépendances, il reste une dernière étape : les récupérer.
Ceci est analogue à `bundle install` :

```bash
$ mix deps.get
```

Et voilà ! Nous avons défini et récupéré les dépendances de notre projet.
Maintenant nous sommes prêts à ajouter des dépendances quand le moment sera venu.

## Environnements

Mix, tout comme Bundler, supporte différents environnements.
Par défaut, Mix est configuré pour avoir trois environnements :

- `:dev` - L'environnement par défaut.
- `:test` - Utilisé par `mix test`. Ce sujet sera abordé dans notre prochaine leçon.
- `:prod` - Utilisé lorsque nous envoyons notre application en production.

L'environnement actuel est accessible en utilisant `Mix.env`.
Comme prévu, l'environnement peut être modifié via la variable d'environnement `MIX_ENV` :

```bash
$ MIX_ENV=prod mix compile
```
