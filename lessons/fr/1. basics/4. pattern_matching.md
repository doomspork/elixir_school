La correspondance de motifs est une partie puissante d'Elixir. Il nous permet de faire correspondre des valeurs simples, des structures de données et même des fonctions.

Dans cette leçon, nous allons commencer à voir comment le filtrage de motifs est utilisé.

## Opérateur de correspondance

Êtes-vous prêt pour une balle courbe ? En Elixir, l'opérateur `=` est en fait un opérateur de correspondance, comparable au signe égal en algèbre. En l'écrivant, on transforme l'expression entière en une équation et Elixir fait correspondre les valeurs de la main gauche avec celles de la main droite. Si la correspondance réussit, il renvoie la valeur de l'équation. Sinon, il envoie une erreur. Jetons un coup d'oeil :

```elixir
iex> x = 1
1
```

Maintenant, essayons une correspondance simple :

```elixir
iex> 1 = x
1
iex> 2 = x
** (MatchError) pas de correspondance pour la valeur de droite : 1
```

Essayons cela avec certaines des collections que nous connaissons :

```elixir
# Listes
iex> list = [1, 2, 3]
[1, 2, 3]
iex> [1, 2, 3] = liste
[1, 2, 3]
iex> [] = liste
** (MatchError) pas de correspondance pour la valeur de droite : [1, 2, 3]

iex> [1 | queue] = liste
[1, 2, 3]
iex> queue
[2, 3]
iex> [2 | _] = liste
** (MatchError) pas de correspondance pour la valeur de droite : [1, 2, 3]

# Tuples
iex> {:ok, valeur} = {:ok, "Successful !"}
{:ok, "Succès !"}
iex> valeur
"Réussi !"
iex> {:ok, valeur} = {:error}
** (MatchError) pas de correspondance avec la valeur de droite : {:error}
```

## Opérateur d'affectation

L'opérateur de correspondance effectue une affectation lorsque le côté gauche de la correspondance comprend une variable.
Dans certains cas, ce comportement de réassignation de variable est indésirable.
Pour ces situations, nous avons l'opérateur pin : `^`.

Lorsque nous épinglons une variable, nous nous basons sur la valeur existante plutôt que de la relier à une nouvelle.
Voyons comment cela fonctionne :

```elixir
iex> x = 1
1
iex> ^x = 2
** (MatchError) pas de correspondance pour la valeur de droite : 2
iex> {x, ^x} = {2, 1}
{2, 1}
iex> x
2
```

Elixir 1.2 a introduit la prise en charge des épingles dans les clés de carte et les clauses de fonction :

```elixir
iex> key = "hello" (Bonjour)
"hello"
iex> %{^key => value} = %{"hello" => "world"}
%{"hello" => "world"}
iex> valeur
"monde"
iex> %{^key => value} = %{:hello => "world"}
** (MatchError) pas de correspondance pour la valeur de droite : %{hello : "world"}
```

Un exemple d'épinglage dans une clause de fonction :

```elixir
iex> greeting = "Bonjour"
"Bonjour"
iex> greeting = fn
...> (^salut, nom) -> "Salut #{nom}"
...> (greeting, name) -> "#{greeting}, #{name}"
...> end
#Fonction<12.54118792/2 in :erl_eval.expr/5>
iex> greet.("Bonjour", "Sean")
"Salut Sean"
iex> greet.("Mornin'", "Sean")
"Mornin', Sean"
iex> greeting
"Bonjour"
```

Notez dans l'exemple de `"Mornin'"` que la réaffectation de `greeting` à `"Mornin'"` se produit uniquement à l'intérieur de la fonction. En dehors de la fonction, `greeting` est toujours `"Hello"`.
