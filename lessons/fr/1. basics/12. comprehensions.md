Les compréhensions de listes sont un sucre syntaxique pour boucler les énumérables dans Elixir.

Dans cette leçon, nous allons voir comment utiliser les compréhensions pour l'itération et la génération.

## Principes de base

Les compréhensions peuvent souvent être utilisées pour produire des déclarations plus concises pour l'itération `Enum` et `Stream`.
Commençons par regarder une compréhension simple, puis décomposons-la :

```elixir
iex> list = [1, 2, 3, 4, 5]
iex> for x <- list, do : x*x
[1, 4, 9, 16, 25]
```

La première chose que l'on remarque est l'utilisation de `for` et d'un générateur.
Qu'est-ce qu'un générateur ?
Les générateurs sont les expressions `x <- [1, 2, 3, 4]` que l'on trouve dans les compréhensions de listes.
Ils sont responsables de la génération de la prochaine valeur.

Heureusement pour nous, les comprehensions ne sont pas limitées aux listes ; en fait, elles fonctionnent avec n'importe quel énumérable :

```elixir
# Listes de mots-clés
iex> pour {_key, val} <- [un : 1, deux : 2, trois : 3], do : val
[1, 2, 3]

# Cartes
iex> for {k, v} <- %{"a" => "A", "b" => "B"}, do : {k, v}
[{"a", "A"}, {"b", "B"}]

# Binaires
iex> for <<c <- "hello">>, do : <<c>>
["h", "e", "l", "l", "o"]
```

Comme beaucoup d'autres choses dans Elixir, les générateurs s'appuient sur la correspondance des motifs pour comparer leur ensemble d'entrée à la variable de gauche.
Dans le cas où une correspondance n'est pas trouvée, la valeur est ignorée :

```elixir
iex> pour {:ok, val} <- [ok : "Hello", error : "Unknown", ok : "World"], do : val
["Bonjour", "Monde"]
```

Il est possible d'utiliser plusieurs générateurs, un peu comme des boucles imbriquées :

```elixir
iex> list = [1, 2, 3, 4]
iex> for n <- list, times <- 1..n do
...> String.duplicate("*", times)
...> fin
["*", "*", "**", "*", "**", "***", "*", "**", "***", "****"]
```

Pour mieux illustrer le bouclage qui se produit, utilisons `IO.puts` pour afficher les deux valeurs générées :

```elixir
iex> for n <- liste, times <- 1..n, do : IO.puts "#{n} - #{times}"
1 - 1
2 - 1
2 - 2
3 - 1
3 - 2
3 - 3
4 - 1
4 - 2
4 - 3
4 - 4
```

Les compréhensions de listes sont un sucre syntaxique et ne doivent être utilisées que lorsque cela est approprié.

## Filtres

Vous pouvez considérer les filtres comme une sorte de garde pour les compréhensions.
Quand une valeur filtrée retourne `false` ou `nil`, elle est exclue de la liste finale.
Bouclons sur une plage et ne nous préoccupons que des nombres pairs.
Nous allons utiliser la fonction `is_even/1` du module Integer pour vérifier si une valeur est paire ou non.

```elixir
import Integer
iex> for x <- 1..10, is_even(x), do : x
[2, 4, 6, 8, 10]
```

Comme les générateurs, nous pouvons utiliser plusieurs filtres.
Étendons notre plage et filtrons ensuite uniquement les valeurs qui sont à la fois paires et divisibles de façon égale par 3.

```elixir
import Integer
iex> for x <- 1..100,
...> is_even(x),
...> rem(x, 3) == 0, do : x
[6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96]
```

## Utilisation de :into

Que faire si l'on veut produire autre chose qu'une liste ?
L'option `:into` nous permet de le faire !
En règle générale, `:into` accepte toute structure qui implémente le protocole `Collectable`.

En utilisant `:into`, créons une carte à partir d'une liste de mots-clés :

```elixir
iex> for {k, v} <- [one : 1, two : 2, three : 3], into : %{}, do : {k, v}
%{un : 1, trois : 3, deux : 2}
```

Puisque les binaires sont des collectibles, nous pouvons utiliser les compréhensions de listes et `:into` pour créer des chaînes de caractères :

```elixir
iex> for c <- [72, 101, 108, 108, 111], into: "", do: <<c>>
"Bonjour"
```

C'est tout !
Les compréhensions de listes sont un moyen facile d'itérer dans des collections de manière concise.
