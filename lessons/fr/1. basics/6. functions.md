Dans Elixir et dans de nombreux langages fonctionnels, les fonctions sont des citoyens de première classe.
Nous allons apprendre les types de fonctions dans Elixir, ce qui les rend différentes, et comment les utiliser.

## Fonctions anonymes

Comme son nom l'indique, une fonction anonyme n'a pas de nom.
Comme nous l'avons vu dans la leçon `Enum`, elles sont fréquemment passées à d'autres fonctions.
Pour définir une fonction anonyme dans Elixir, nous avons besoin des mots-clés `fn` et `end`.
A l'intérieur de ceux-ci, nous pouvons définir un nombre quelconque de paramètres et de corps de fonctions séparés par des `->`.

Voyons un exemple de base :

```elixir
iex> sum = fn (a, b) -> a + b end
iex> sum.(2, 3)
5
```

### L'abréviation &

L'utilisation de fonctions anonymes est une pratique tellement courante dans Elixir qu'il existe un raccourci pour le faire :

```elixir
iex> sum = &(&1 + &2)
iex> sum.(2, 3)
5
```

Comme vous l'avez probablement déjà deviné, dans la version abrégée, nos paramètres sont disponibles sous la forme de `&1`, `&2`, `&3`, et ainsi de suite.

## Le filtrage par motif

Le filtrage n'est pas limité aux variables dans Elixir, il peut être appliqué aux signatures de fonctions comme nous allons le voir dans cette section.

Elixir utilise le filtrage pour vérifier toutes les options de correspondance possibles et sélectionner la première option à exécuter :

```elixir
iex> handle_result = fn
...> {:ok, result} -> IO.puts "Handling result..." (Traitement du résultat)
...> {:ok, _} -> IO.puts "Cette opération ne sera jamais exécutée car les résultats précédents seront comparés à l'avance."
...> {:error} -> IO.puts "Une erreur s'est produite !"
...> end

iex> some_result = 1
1
iex> handle_result.({:ok, some_result})
Traitement du résultat...
:ok
iex> handle_result.({:error})
Une erreur s'est produite !
:ok
```

## Fonctions nommées

Nous pouvons définir des fonctions avec des noms afin de pouvoir y faire référence facilement par la suite.
Les fonctions nommées sont définies dans un module en utilisant le mot-clé `def`.
Nous en apprendrons plus sur les modules dans les prochaines leçons, pour l'instant nous nous concentrerons uniquement sur les fonctions nommées.

Les fonctions définies dans un module peuvent être utilisées par d'autres modules.
Il s'agit d'un bloc de construction particulièrement utile en Elixir :

```elixir
defmodule Greeter do
  def hello(name) do
    "Bonjour, " <> nom
  end
end

iex> Greeter.hello("Sean")
"Bonjour, Sean"
```

Si le corps de notre fonction ne s'étend que sur une ligne, nous pouvons encore le raccourcir avec `do:` :

```elixir
defmodule Greeter do
  def hello(nom), do : "Bonjour, " <> nom
end
```

Armés de notre connaissance du pattern matching, explorons la récursion en utilisant des fonctions nommées :

```elixir
defmodule Longueur do
  def of([]), do : 0
  def of([_ | queue]), do : 1 + of(tail)
end

iex> Longueur.de []
0
iex> Longueur.de [1, 2, 3]
3
```

### Nom des fonctions et arité

Nous avons mentionné précédemment que les fonctions sont nommées par la combinaison du nom donné et de l'arité (nombre d'arguments).
Cela signifie que vous pouvez faire des choses comme ceci :

```elixir
defmodule Greeter2 do
  def hello(), do : "Bonjour, personne anonyme !"   # hello/0
  def hello(name), do : "Bonjour, " <> nom # bonjour/1
  def hello(nom1, nom2), do : "Bonjour, #{nom1} et #{nom2}"
                                                # bonjour/2
end

iex> Greeter2.hello()
"Bonjour, personne anonyme !"
iex> Greeter2.hello("Fred")
"Bonjour, Fred"
iex> Greeter2.hello("Fred", "Jane")
"Bonjour, Fred et Jane"
```

Nous avons listé les noms des fonctions dans les commentaires ci-dessus.
La première implémentation ne prend aucun argument, elle est donc connue sous le nom de `hello/0` ; la seconde prend un argument, elle est donc connue sous le nom de `hello/1`, et ainsi de suite.
Contrairement aux surcharges de fonctions dans d'autres langages, ces fonctions sont considérées comme des fonctions _différentes_ les unes des autres.
(Le filtrage par motif, décrit il y a un instant, ne s'applique que lorsque plusieurs définitions sont fournies pour des définitions de fonctions ayant le _même_ nombre d'arguments).

### Fonctions et filtrage

En coulisses, les fonctions effectuent un filtrage des arguments avec lesquels elles sont appelées.

Supposons que nous ayons besoin d'une fonction acceptant une map mais que nous ne soyons intéressés que par l'utilisation d'une clé particulière.
Nous pouvons effectuer un filtrage sur la présence de cette clé dans l'argument, comme ceci :

```elixir
defmodule Greeter1 do
  def hello(%{name : person_name}) do
    IO.puts "Bonjour, " <> nom_de_personne
  end
end
```

Maintenant, disons que nous avons une carte décrivant une personne nommée Fred :

```elixir
iex> fred = %{
...> nom : "Fred",
...> âge : "95",
...> couleur_favorite : "Taupe"
...> }
```

Voici les résultats que nous obtiendrons lorsque nous appellerons `Greeter1.hello/1` avec la carte `fred` :

```elixir
# appel avec l'ensemble de la table
...> Greeter1.hello(fred)
"Bonjour, Fred"
```

Que se passe-t-il lorsque nous appelons la fonction avec une map qui ne contient pas la clé `:name` ?

```elixir
# L'appel sans la clé dont nous avons besoin renvoie une erreur
...> Greeter1.hello(%{age : "95", favorite_color : "Taupe"})
** (FunctionClauseError) aucune clause de fonction correspondante dans Greeter1.hello/1

    Les arguments suivants ont été donnés à Greeter1.hello/1 :

        # 1
        %{age : "95", favorite_color : "Taupe"}

    iex:12 : Greeter1.hello/1

```

La raison de ce comportement est qu'Elixir compare les arguments avec lesquels une fonction est appelée à l'arité avec laquelle la fonction est définie.

Réfléchissons à l'aspect des données lorsqu'elles arrivent sur `Greeter1.hello/1` :

```elixir
# carte entrante
iex> fred = %{
...> nom : "Fred",
...> âge : "95",
...> couleur_favorite : "Taupe"
...> }
```

`Greeter1.hello/1` attend un argument comme celui-ci :

```elixir
%{nom : nom_de_personne}
```

Dans `Greeter1.hello/1`, la carte que nous passons (`fred`) est évaluée par rapport à notre argument (`%{name : person_name}`) :

```elixir
%{name : person_name} = %{name : "Fred", age : "95", favorite_color : "Taupe"}
```

Il trouve qu'il y a une clé qui correspond à `name` dans la carte entrante.
Nous avons une correspondance ! Et comme résultat de cette correspondance réussie, la valeur de la clé `:name` dans la map de droite (c'est-à-dire la map `fred`) est liée à la variable de gauche (`person_name`).

Maintenant, que se passe-t-il si nous voulons toujours assigner le nom de Fred à `person_name` mais que nous voulons AUSSI garder la connaissance de l'ensemble de la map person ? Disons que nous voulons faire `IO.inspect(fred)` après l'avoir salué.
À ce stade, comme nous n'avons effectué une reconnaissance de motif que sur la clé `:name` de notre carte, et que nous n'avons donc lié que la valeur de cette clé à une variable, la fonction n'a pas connaissance du reste de Fred.

Afin de le conserver, nous devons assigner cette carte entière à sa propre variable pour pouvoir l'utiliser.

Commençons une nouvelle fonction :

```elixir
defmodule Greeter2 do
  def hello(%{name : person_name} = person) do
    IO.puts "Bonjour, " <> nom_de_personne
    IO.inspecter la personne
  end
end
```

Rappelez-vous qu'Elixir effectuera une correspondance de motif sur l'argument entrant.
Par conséquent, dans ce cas, chaque partie correspondra à l'argument entrant et se liera à ce qui lui correspond.
Prenons d'abord le côté droit :

```elixir
person = %{name : "Fred", age : "95", favorite_color : "Taupe"}
```

Maintenant, `person` a été évalué et lié à l'ensemble de fred-map.
Nous passons au pattern-match suivant :

```elixir
%{name : person_name} = %{name : "Fred", age : "95", favorite_color : "Taupe"}
```

C'est la même chose que notre fonction `Greeter1` originale, où nous avons effectué une recherche par motif dans la carte et n'avons retenu que le nom de Fred.
Ce que nous avons obtenu, c'est deux variables que nous pouvons utiliser au lieu d'une :

1. `person`, faisant référence à `%{name : "Fred", age : "95", favorite_color : "Taupe"}`
2. `personne_nom`, se référant à `"Fred"`.

Donc maintenant, lorsque nous appelons `Greeter2.hello/1`, nous pouvons utiliser toutes les informations de Fred :

```elixir
# appel avec la personne entière
...> Greeter2.hello(fred)
"Bonjour, Fred"
%{age : "95", favorite_color : "Taupe", name : "Fred"}
# appel avec seulement la clé du nom
...> Greeter2.hello(%{name : "Fred"})
"Bonjour, Fred"
%{name : "Fred"}
# appel sans la clé du nom
...> Greeter2.hello(%{age : "95", favorite_color : "Taupe"})
** (FunctionClauseError) aucune clause de fonction correspondante dans Greeter2.hello/1

    Les arguments suivants ont été donnés à Greeter2.hello/1 :

        # 1
        %{age : "95", favorite_color : "Taupe"}

    iex:15 : Greeter2.hello/1
```

Nous avons donc vu qu'Elixir effectue un filtrage à plusieurs niveaux, car chaque argument correspond aux données entrantes indépendamment, ce qui nous laisse les variables pour les appeler dans notre fonction.

Si nous inversons l'ordre de `%{name : person_name}` et `person` dans la liste, nous obtiendrons le même résultat car chacun correspond à fred de manière indépendante.

Nous échangeons la variable et la carte :

```elixir
defmodule Greeter3 do
  def hello(person = %{name : person_name}) do
    IO.puts "Bonjour, " <> nom_de_la_personne
    IO.inspect person
  end
end
```

Et appelez-le avec les mêmes données que nous avons utilisées dans `Greeter2.hello/1` :

```elixir
# Appel avec le même vieux Fred
...> Greeter3.hello(fred)
"Bonjour, Fred"
%{age : "95", favorite_color : "Taupe", name : "Fred"}
```

Rappelez-vous que même si vous avez l'impression que `%{name : person_name} = person` compare les `%{name : person_name}` avec la variable `person`, ils comparent en fait _chacun_ avec l'argument passé.

**Résumé:** Les fonctions appliquent un filtrage aux données transmises à chacun de leurs arguments indépendamment.
Nous pouvons utiliser cela pour lier des valeurs à des variables distinctes au sein de la fonction.

### Fonctions privées

Lorsque nous ne voulons pas que d'autres modules accèdent à une fonction spécifique, nous pouvons rendre la fonction privée.
Les fonctions privées ne peuvent être appelées que depuis leur propre module.
Nous les définissons dans Elixir avec `defp` :

```elixir
defmodule Greeter do
  def hello(name), do : phrase() <> name
  defp phrase, do : "Bonjour, "
end

iex> Greeter.hello("Sean")
"Bonjour, Sean"

iex> Greeter.phrase
** (UndefinedFunctionError) la fonction Greeter.phrase/0 est indéfinie ou privée
    Greeter.phrase()
```

### Gardes

Nous avons brièvement abordé les gardes dans la leçon [Control Structures](/fr/lessons/basics/control_structures), maintenant nous allons voir comment les appliquer aux fonctions nommées.
Une fois que Elixir a fait correspondre une fonction, toutes les gardes existantes seront testées.

Dans l'exemple suivant, nous avons deux fonctions avec la même signature, nous comptons sur les gardes pour déterminer laquelle utiliser en fonction du type de l'argument :

```elixir
defmodule Greeter do
  def hello(names) when is_list(names) do
    names = Enum.join(names, ", ")
    
    hello(noms)
  end

  def hello(name) when is_binary(name) do
    phrase() <> nom
  end

  defp phrase, do : "Bonjour, "
end

iex> Greeter.hello ["Sean", "Steve"]
"Bonjour, Sean, Steve"
```

### Arguments par défaut

Si nous voulons une valeur par défaut pour un argument, nous utilisons la syntaxe argument `valeur` :

```elixir
defmodule Greeter do
  def hello(name, language_code \\\\"en") do
    phrase(code_langue) <> nom
  end

  defp phrase("en"), do : "Bonjour, "
  defp phrase("es"), do : "Hola, "
end

iex> Greeter.hello("Sean", "en")
"Bonjour, Sean"

iex> Greeter.hello("Sean")
"Bonjour, Sean"

iex> Greeter.hello("Sean", "es")
"Hola, Sean"
```

Lorsque nous combinons notre exemple de garde avec des arguments par défaut, nous rencontrons un problème.
Voyons à quoi cela peut ressembler :

```elixir
defmodule Greeter do
  def hello(names, language_code \\\"en") when is_list(names) do
    names = Enum.join(names, ", ")
    
    hello(noms, code_langue)
  end

  def hello(name, language_code \\"en") when is_binary(name) do
    phrase(code_langue) <> nom
  end

  defp phrase("en"), do : "Bonjour, "
  defp phrase("es"), do : "Hola, "
end

** (CompileError) iex:8 : def hello/2 définit les valeurs par défaut plusieurs fois. Elixir permet de déclarer les valeurs par défaut une fois par définition.
Au lieu de :

    def foo(:first_clause, b \\\\ :default) do ... end
    def foo(:second_clause, b \\\\N :default) do ... end

on devrait écrire

    def foo(a, b \ :default)
    def foo(:première_clause, b) do ... fin
    def foo(:second_clause, b) do ... end
```

Elixir n'aime pas les arguments par défaut dans les fonctions à correspondances multiples, cela peut prêter à confusion.
Pour gérer cela, nous ajoutons une tête de fonction avec nos arguments par défaut :

```elixir
defmodule Greeter do
  def hello(names, language_code \\"en")

  def hello(names, language_code) when is_list(names) do
    names = Enum.join(names, ", ")

    hello(noms, code_langue)
  end

  def hello(nom, code_langue) when is_binary(nom) do
    phrase(code_langue) <> nom
  end

  defp phrase("en"), do : "Bonjour, "
  defp phrase("es"), do : "Hola, "
end

iex> Greeter.hello ["Sean", "Steve"]
"Bonjour, Sean, Steve"

iex> Greeter.hello ["Sean", "Steve"], "es"
"Hola, Sean, Steve"
```
