Mise en route, types de données de base, et opérations de base.

## Démarrage

### Installation d'Elixir

Les instructions d'installation pour chaque système d'exploitation se trouvent sur elixir-lang.org dans le guide [Installing Elixir](http://elixir-lang.org/install.html).

Une fois Elixir installé, vous pouvez facilement trouver la version installée.

    % elixir -v
    Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

    Elixir {{ site.elixir.version }}

### Essayer le mode interactif

Elixir est livré avec IEx, un shell interactif, qui nous permet d'évaluer les expressions Elixir au fur et à mesure.

Pour commencer, exécutons `iex` :

    Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

    Interactive Elixir ({{ site.elixir.version }}) - press Ctrl+C to exit (type h() ENTER for help)
    iex>

Note : Sous Windows PowerShell, vous devez taper `iex.bat`.

Allons-y et essayons maintenant en tapant quelques expressions simples :

```elixir
iex> 2+3
5
iex> 2+3 == 5
true
iex> String.length("The quick brown fox jumps over the lazy dog")
43
```

Ne vous inquiétez pas si vous ne comprenez pas encore toutes les expressions, mais nous espérons que vous avez compris l'idée.

## Types de données de base

### Entiers

```elixir
iex> 255
255
```

La prise en charge des nombres binaires, octaux et hexadécimaux est intégrée :

```elixir
iex> 0b0110
6
iex> 0o644
420
iex> 0x1F
31
```

### Nombres flottants

En Elixir, les nombres à virgule flottante nécessitent une décimale après au moins un chiffre ; ils ont une double précision de 64 bits et supportent `e` pour les exposants :

```elixir
iex> 3.14
3.14
iex> .14
** (SyntaxError) iex:2: syntax error before: '.'
iex> 1.0e-10
1.0e-10
```

### Booléens

Elixir supporte `true` et `false` comme booléens ; tout est vrai sauf `false` et `nil` :

```elixir
iex> true
true
iex> false
false
```

### Atomes

Un atome est une constante dont le nom est sa valeur.
Si vous êtes familier avec Ruby, ils sont synonymes de Symboles :

```elixir
iex> :foo
:foo
iex> :foo == :bar
false
```

Les booléens `true` et `false` sont aussi les atomes `:true` et `:false`, respectivement.

```elixir
iex> is_atom(true)
true
iex> is_boolean(:true)
true
iex> :true === true
true
```

Les noms de modules en Elixir sont également des atomes. `MyApp.MyModule` est un atome valide, même si un tel module n'a pas encore été déclaré.

```elixir
iex> is_atom(MyApp.MyModule)
true
```

Les atomes sont également utilisés pour référencer les modules des bibliothèques Erlang, y compris les modules intégrés.

```elixir
iex> :crypto.strong_rand_bytes 3
<<23, 104, 108>>
```

### Chaînes de caractères

Les chaînes de caractères dans Elixir sont codées en UTF-8 et sont entourées de guillemets doubles :

```elixir
iex> "Hello"
"Hello"
iex> "dziękuję"
"dziękuję"
```

Les chaînes de caractères supportent les sauts de ligne et les séquences d'échappement :

```elixir
iex> "foo
...> bar"
"foo\nbar"
iex> "foo\nbar"
"foo\nbar"
```

Elixir comprend également des types de données plus complexes.
Nous en apprendrons davantage à leur sujet lorsque nous étudierons les [collections](/fr/lessons/basics/collections) et les [fonctions](/fr/lessons/basics/functions).

## Opérations de base

### Arithmétique

Elixir supporte les opérateurs de base `+`, `-`, `*`, et `/` comme vous pouvez vous y attendre.
Il est important de se rappeler que `/` retournera toujours un flottant :

```elixir
iex> 2 + 2
4
iex> 2 - 1
1
iex> 2 * 5
10
iex> 10 / 5
2.0
```

Si vous avez besoin de la division d'entiers ou du reste de la division (c'est-à-dire, modulo), Elixir est livré avec deux fonctions utiles pour y parvenir :

```elixir
iex> div(10, 5)
2
iex> rem(10, 3)
1
```

### Booléen

Elixir fournit les opérateurs booléens `||`, `&&`, et `!`.
Ils supportent tous les types :

```elixir
iex> -20 || true
-20
iex> false || 42
42

iex> 42 && true
true
iex> 42 && nil
nil

iex> !42
false
iex> !false
true
```

Il existe trois opérateurs supplémentaires dont le premier argument _doit_ être un booléen (`vrai` ou `faux`) :

```elixir
iex> true and 42
42
iex> false or true
true
iex> not false
true
iex> 42 and true
** (ArgumentError) argument error: 42
iex> not 42
** (ArgumentError) argument error
```

Note : Les `and` et `or` d'Elixir correspondent en fait à `andalso` et `orelse` en Erlang.

### Comparaison

Elixir est livré avec tous les opérateurs de comparaison auxquels nous sommes habitués : `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<`, et `>`.

```elixir
iex> 1 > 2
false
iex> 1 != 2
true
iex> 2 == 2
true
iex> 2 <= 3
true
```

Pour une comparaison stricte des entiers et des flottants, utilisez `===` :

```elixir
iex> 2 == 2.0
true
iex> 2 === 2.0
false
```

Une caractéristique importante d'Elixir est que deux types quelconques peuvent être comparés ; ceci est particulièrement utile pour le tri. Nous n'avons pas besoin de mémoriser l'ordre de tri, mais il est important d'en être conscient :

```elixir
number < atom < reference < function < port < pid < tuple < map < list < bitstring
```

Cela peut conduire à des comparaisons intéressantes, mais valables, que vous ne trouverez peut-être pas dans d'autres langues :

```elixir
iex> :hello > 999
true
iex> {:hello, :world} > [1, 2, 3]
false
```

### Interpolation de chaînes de caractères

Si vous avez utilisé Ruby, l'interpolation de chaînes dans Elixir vous semblera familière :

```elixir
iex> name = "Sean"
"Sean"
iex> "Hello #{name}"
"Hello Sean"
```
### Concaténation de chaînes de caractères

La concaténation de chaînes de caractères utilise l'opérateur `<>` :

```elixir
iex> name = "Sean"
"Sean"
iex> "Hello " <> name
"Hello Sean"
```
