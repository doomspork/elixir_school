IEx Helpers

## Vue d'ensemble

Lorsque vous commencez à travailler en Elixir, IEx est votre meilleur ami.
Il s'agit d'un REPL, mais il possède de nombreuses fonctionnalités avancées qui peuvent vous faciliter la vie lorsque vous explorez un nouveau code ou que vous développez votre travail au fur et à mesure.
Il existe un grand nombre d'aides intégrées que nous allons aborder dans cette leçon.

### Autocomplétion

Lorsque vous travaillez dans l'interpréteur de commandes, vous vous retrouvez souvent à utiliser un nouveau module qui ne vous est pas familier.
Pour comprendre une partie de ce qui est à votre disposition, la fonctionnalité d'autocomplétion est merveilleuse.
Tapez simplement le nom d'un module suivi de `.` puis appuyez sur `Tab` :

```elixir
iex> Map. # appuyez sur Tab
delete/2 drop/2 equal?/2
fetch!/2 fetch/2 from_struct/1
get/2 get/3 get_and_update!/3
get_and_update/3 get_lazy/3 has_key?/2
keys/1 merge/2 merge/3
new/0 new/1 new/2
pop/2 pop/3 pop_lazy/3
put/3 put_new/3 put_new_lazy/3
replace!/3 replace/3 split/2
take/2 to_list/1 update!/3
update/4 valeurs/1
```

Et maintenant nous connaissons les fonctions que nous avons et leur arité !

### .iex.exs

Chaque fois que IEx démarre, il cherche un fichier de configuration `.iex.exs`.
S'il n'est pas présent dans le répertoire courant, alors le répertoire personnel de l'utilisateur (`~/.iex.exs`) sera utilisé comme solution de repli.

Les options de configuration et le code définis dans ce fichier seront à notre disposition au démarrage du shell IEx.
Par exemple, si nous voulons que certaines fonctions d'aide soient disponibles dans IEx, nous pouvons ouvrir `.iex.exs` et faire quelques changements.

Commençons par ajouter un module avec quelques fonctions d'aide :

```elixir
defmodule IExHelpers do
  def whats_this ?(term) when is_nil(term), do : "Type : Nil".
  def whats_this ?(term) when is_binary(term), do : "Type : Binaire".
  def whats_this ?(term) when is_boolean(term), do : "Type : Booléen".
  def whats_this ?(term) when is_atom(term), do : "Type : Atome".
  def whats_this ?(_term), do : "Type : Inconnu".
end
```

Maintenant, lorsque nous lançons IEx, nous avons le module IExHelpers à notre disposition dès le départ.
Ouvrez IEx et essayons nos nouvelles aides :

```elixir
$ iex
{{ site.erlang.OTP }} [{{ site.erlang.erts }}] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Elixir interactif ({{ site.elixir.version }}) - appuyez sur Ctrl+C pour quitter (tapez h() ENTER pour obtenir de l'aide)
iex> IExHelpers.whats_this ?("une chaîne")
"Type : Binaire "
iex> IExHelpers.whats_this ?(%{})
"Type : Unknown" (Inconnu)
iex> IExHelpers.whats_this ?(:test)
"Type : Atome"
```

Comme nous pouvons le constater, nous n'avons pas besoin de faire quoi que ce soit de spécial pour exiger ou importer nos aides, IEx s'en charge pour nous.

### h

`h` est l'un des outils les plus utiles que nous offre notre shell Elixir.
Grâce au fantastique support de première classe de la documentation du langage, les docs de n'importe quel code peuvent être atteints en utilisant cette aide.
Pour le voir en action, c'est simple :

```elixir
iex> h Enum
                                      Enum

Fournit un ensemble d'algorithmes qui énumèrent sur des énumérables selon le protocole
protocole Enumerable.

┃ iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)
┃ [2, 4, 6]

```

Certains types particuliers, comme les maps, donnent un format spécifique à l'énumération.
Par exemple, l'argument est toujours un tuple {key, value} pour les maps :

```elixir
┃ iex> map = %{a : 1, b : 2}
┃ iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)
┃ [a : 2, b : 4]
```

Notez que les fonctions du module Enum sont avides : elles commencent toujours l'énumération de l'énumération donnée.
l'énumération de l'énumérable donné.
Le module Stream permet d'effectuer une énumération paresseuse
des énumérables et fournit des flux infinis.

Puisque la majorité des fonctions du module Enum énumèrent la totalité de l'énumérable et renvoient une liste en tant que résultat, les flux infinis ne peuvent être utilisés.
et retournent une liste comme résultat, les flux infinis doivent être utilisés avec précaution avec de telles fonctions, car ils peuvent potentiellement s'exécuter indéfiniment.
fonctions, car ils peuvent potentiellement s'exécuter à l'infini.
Par exemple :

```elixir
┃ Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)
```

Et maintenant, nous pouvons même combiner cela avec les fonctionnalités d'autocomplétion de notre shell.
Imaginez que nous explorions Map pour la première fois :

```elixir
iex> h Map
                                      Map

Un ensemble de fonctions permettant de travailler avec des cartes.

Les maps sont des magasins clé-valeur où les clés peuvent être n'importe quelle valeur et sont comparées en utilisant
l'opérateur de correspondance (===).
Les cartes peuvent être créées avec la forme spéciale %{} définie dans le module
dans le module Kernel.SpecialForms.

iex> Carte.
delete/2 drop/2 equal?/2
fetch!/2 fetch/2 from_struct/1
get/2 get/3 get_and_update!/3
get_and_update/3 get_lazy/3 has_key?/2
keys/1 merge/2 merge/3
new/0 new/1 new/2
pop/2 pop/3 pop_lazy/3
put/3 put_new/3 put_new_lazy/3
split/2 take/2 to_list/1
update!/3 update/4 valeurs/1

iex> h Map.merge/2
                             def merge(carte1, carte2)

Fusionne deux cartes en une seule.

Toutes les clés de map2 seront ajoutées à map1, en écrasant toute clé existante.

Si vous avez une structure et que vous souhaitez fusionner un ensemble de clés dans la structure,
n'utilisez pas cette fonction, car elle fusionnerait toutes les clés du côté droit dans la structure.
struct, même si la clé ne fait pas partie de la struct.
À la place, utilisez
Kernel.struct/2.

Exemples

┃ iex> Map.merge(%{a : 1, b : 2}, %{a : 3, d : 4})
┃ %{a : 3, b : 2, d : 4}
```

Comme nous pouvons le voir, nous n'avons pas seulement été capables de trouver les fonctions disponibles dans le cadre du module, mais nous avons pu accéder aux docs des fonctions individuelles, dont beaucoup incluent des exemples d'utilisation.

### i

Mettons à profit nos nouvelles connaissances en utilisant `h` pour en apprendre un peu plus sur l'aide `i` :

```elixir
iex> h i

                                  def i(terme)

Affiche des informations sur le type de données donné.

iex> i Map
Terme
  Map
Type de données
  Atome
Module bytecode
  /usr/local/Cellar/elixir/1.3.3/bin/../lib/elixir/ebin/Elixir.Map.beam
Source
  /private/tmp/elixir-20160918-33925-1ki46ng/elixir-1.3.3/lib/elixir/lib/map.ex
Version
  [9651177287794427227743899018880159024]
Temps de compilation
  aucune valeur trouvée
Options de compilation
  [:debug_info]
Description
  Utilisez h(Map) pour accéder à sa documentation.
  Appelez Map.module_info() pour accéder aux métadonnées.
Représentation brute
  : "Elixir.Map"
Modules de référence
  Module, Atom
```

Maintenant, nous avons un tas d'informations sur `Map`, y compris où sa source est stockée et les modules qu'elle référence.
Ceci est très utile lorsque l'on explore des types de données personnalisés, étrangers, et de nouvelles fonctions.

Les rubriques individuelles peuvent être denses, mais à un haut niveau, nous pouvons rassembler des informations pertinentes :

- C'est un type de données atomique
- Où se trouve le code source
- La version, et les options de compilation
- Une description générale
- Comment y accéder
- Les autres modules auxquels il fait référence

Cela nous donne de quoi travailler et c'est mieux que d'y aller à l'aveuglette.

### r

Si nous voulons recompiler un module particulier, nous pouvons utiliser l'aide `r`.
Disons que nous avons modifié du code et que nous voulons exécuter une nouvelle fonction que nous avons ajoutée.
Pour cela, nous devons enregistrer nos modifications et recompiler avec r :

```elixir
iex> r MonProjet
warning : redéfinition du module MyProject (version actuelle chargée depuis _build/dev/lib/my_project/ebin/Elixir.MyProject.beam)
  lib/my_project.ex:1

{:reloaded, MonProjet, [MonProjet]}
```

### t

L'aide `t` nous indique les Types disponibles dans un module donné :

```elixir
iex> t Carte
@type key() : : any()
@type value() : : any()
```

Maintenant, nous savons que `Map` définit les types key et value dans son implémentation.
Si nous regardons les sources de `Map` :

```elixir
defmodule Map do
# ...
  @type key : : any
  @type value : : any
# ...
```

Il s'agit d'un exemple simple, indiquant que les clés et les valeurs de l'implémentation peuvent être de n'importe quel type, mais il est utile de le savoir.

En tirant parti de toutes ces subtilités intégrées, nous pouvons facilement explorer le code et en apprendre davantage sur la façon dont les choses fonctionnent.
IEx est un outil très puissant et robuste qui donne du pouvoir aux développeurs.
Avec ces outils dans notre boîte à outils, l'exploration et la construction peuvent être encore plus amusantes !
