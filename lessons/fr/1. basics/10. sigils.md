Travailler avec et créer des sigils.

## Aperçu des sigils

Elixir fournit une syntaxe alternative pour représenter et travailler avec les littéraux.
Un sigil commence par un tilde `~` suivi d'un caractère.
Le noyau d'Elixir nous fournit quelques sigils intégrés, cependant, il est possible de créer les nôtres lorsque nous avons besoin d'étendre le langage.

Voici une liste des sigils disponibles :

  - `~C` Génère une liste de caractères **sans** échappement ni interpolation.
  - `~c` Génère une liste de caractères **avec** échappement et interpolation
  - `~R` Génère une expression régulière **sans** échappement ni interpolation
  - `~r` Génère une expression régulière **avec** échappement et interpolation
  - `~S` Génère une chaîne de caractères **sans** échappement ni interpolation
  - `~s` Génère une chaîne de caractères **avec** échappement et interpolation
  - `~W` Génère une liste de mots **sans** échappement ni interpolation
  - `~w` Génère une liste de mots **avec** échappement et interpolation.
  - `~N` Génère une structure `NaiveDateTime`.
  - `~U` Génère une structure `DateTime` (depuis Elixir 1.9.0)

Une liste de délimiteurs comprend :

  - `<...>` Une paire de parenthèses pointues
  - `{...}` Une paire de crochets arrondis
  - `[...]` Une paire de crochets carrés
  - `(...)` Une paire de parenthèses
  - `|...|` Une paire de tuyaux
  - `/.../` Une paire de barres obliques avant
  - `"..."` Une paire de guillemets doubles
  - `"..."` Une paire de guillemets simples

### Liste des caractères

Les sigles `~c` et `~C` génèrent respectivement des listes de caractères.
Par exemple :

```elixir
iex> ~c/2 + 7 = #{2 + 7}/
'2 + 7 = 9'

iex> ~C/2 + 7 = #{2 + 7}/
'2 + 7 = \#{2 + 7}'
```

On voit que le `~c` minuscule interpole le calcul, alors que le sigle `~C` majuscule ne le fait pas.
Nous verrons que cette séquence majuscule/minuscule est un thème commun à tous les sigils intégrés.

### Expressions régulières

Les sigils `~r` et `~R` sont utilisés pour représenter les Expressions Régulières.
Nous les créons soit à la volée, soit pour les utiliser avec les fonctions `Regex`.
Par exemple :

```elixir
iex> re = ~r/elixir/
~r/elixir/

iex> "Elixir" =~ re
faux

iex> "elixir" =~ re
true
```

Nous pouvons voir que dans le premier test d'égalité, `Elixir` ne correspond pas à l'expression régulière.
Cela est dû au fait qu'il est en majuscule.
Comme Elixir supporte les Expressions Régulières Compatibles Perl (PCRE), nous pouvons ajouter `i` à la fin de notre sigle pour désactiver la sensibilité à la casse.

```elixir
iex> re = ~r/elixir/i
~r/elixir/i

iex> "Elixir" =~ re
true

iex> "elixir" =~ re
true
```

De plus, Elixir fournit l'API [Regex](https://hexdocs.pm/elixir/Regex.html) qui est construite au-dessus de la bibliothèque d'expressions régulières d'Erlang.
Utilisons `Regex.split/2` avec un sigle de regex :

```elixir
iex> string = "100_000_000"
"100_000_000"

iex> Regex.split(~r/_/, string)
["100", "000", "000"]
```

Comme nous pouvons le voir, la chaîne `"100_000_000"` est divisée sur le trait de soulignement grâce à notre sigle `~r/_/`.
La fonction `Regex.split` renvoie une liste.

### Chaîne

Les sigils `~s` et `~S` sont utilisés pour générer des données de type chaîne.
Par exemple :

```elixir
iex> ~s/le chat dans le chapeau sur le paillasson/
"le chat dans le chapeau sur le paillasson"

iex> ~S/le chat dans le chapeau sur le tapis/
"le chat dans le chapeau sur le paillasson"
```

Quelle est la différence ? La différence est similaire au sigil de la liste des caractères que nous avons examiné.
La réponse est l'interpolation et l'utilisation de séquences d'échappement.
Si nous prenons un autre exemple :

```elixir
iex> ~s/welcome to elixir #{String.downcase "SCHOOL"}/
"bienvenue à l'école elixir"

iex> ~S/bienvenue à l'élixir #{String.downcase "SCHOOL"}/
"Bienvenue à l'élixir #{Chaîne.minuscule "SCHOOL"}/"
```

### Liste de mots

Le sigil liste de mots peut s'avérer utile de temps en temps.
Il permet de gagner du temps, d'économiser des frappes et de réduire la complexité de la base de code.
Prenez cet exemple simple :

```elixir
iex> ~w/i love elixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love elixir school/
["i", "love", "elixir", "school"]
```

Nous pouvons voir que ce qui est tapé entre les délimiteurs est séparé par des espaces dans une liste.
Cependant, il n'y a aucune différence entre ces deux exemples.
Là encore, la différence vient de l'interpolation et des séquences d'échappement.
Prenons l'exemple suivant :

```elixir
iex> ~w/i love #{'e'}lixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love #{'e'}lixir school/
["i", "love", "\#{'e'}lixir", "school"]
```

### NaiveDateTime

Un [NaiveDateTime](https://hexdocs.pm/elixir/NaiveDateTime.html) peut être utile pour créer rapidement une structure représentant une `DateTime` **sans** fuseau horaire.

Dans la plupart des cas, nous devrions éviter de créer directement une structure `NaiveDateTime`.
Cependant, elle est utile pour le filtrage.
Par exemple :

```elixir
iex> NaiveDateTime.from_iso8601("2015-01-23 23:50:07") == {:ok, ~N[2015-01-23 23:50:07]}
```

### DateTime

Une [DateTime](https://hexdocs.pm/elixir/DateTime.html) peut s'avérer utile pour créer rapidement 
une structure pour représenter un `DateTime` **avec** un fuseau horaire UTC. Puisque c'est dans le fuseau horaire UTC 
et que votre chaîne de caractères peut représenter un fuseau horaire différent, un troisième élément est retourné qui représente le décalage en secondes. 
le décalage en secondes.

Par exemple :

```elixir
iex> DateTime.from_iso8601("2015-01-23 23:50:07Z") == {:ok, ~U[2015-01-23 23:50:07Z], 0}
iex> DateTime.from_iso8601("2015-01-23 23:50:07-0600") == {:ok, ~U[2015-01-24 05:50:07Z], -21600}
```

## Création de sigils

L'un des objectifs d'Elixir est d'être un langage de programmation extensible.
Il ne devrait donc pas être surprenant que vous puissiez facilement créer vos propres sigils personnalisés.
Dans cet exemple, nous allons créer un sigil pour convertir une chaîne de caractères en majuscules.
Comme il existe déjà une fonction pour cela dans le noyau Elixir (`String.upcase/1`), nous allons envelopper notre sigil autour de cette fonction.

```elixir

iex> defmodule MySigils do
...> def sigil_p(string, []), do : String.upcase(string)
...> fin

iex> import MySigils
nil

iex> ~p/elixir school/
ELIXIR SCHOOL
```

Tout d'abord, nous définissons un module appelé `MySigils` et dans ce module, nous créons une fonction appelée `sigil_p`.
Comme il n'y a pas de sigil `~p` existant dans l'espace sigil existant, nous allons l'utiliser.
Le `_p` indique que nous souhaitons utiliser `p` comme caractère après le tilde.
La définition de la fonction doit prendre deux arguments, une entrée et une liste.
