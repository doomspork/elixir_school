L'opérateur pipe `|>` passe le résultat d'une expression comme premier paramètre d'une autre expression.

## Introduction

La programmation peut être désordonnée.
Tellement désordonnée en fait que les appels de fonctions peuvent être tellement imbriqués qu'ils deviennent difficiles à suivre.
Prenez en considération les fonctions imbriquées suivantes :

```elixir
foo(bar(baz(nouvelle_fonction(autre_fonction()))))
```

Ici, nous passons la valeur `other_function/0` à `new_function/1`, et `new_function/1` à `baz/1`, `baz/1` à `bar/1`, et enfin le résultat de `bar/1` à `foo/1`.
Elixir adopte une approche pragmatique de ce chaos syntaxique en nous donnant l'opérateur pipe.
L'opérateur pipe, qui ressemble à `|>`, _prend le résultat d'une expression et le transmet_.
Regardons à nouveau le bout de code ci-dessus réécrit avec l'opérateur pipe.

```elixir
autre_fonction() |> nouvelle_fonction() |> baz() |> bar() |> foo()
```

L'opérateur pipe prend le résultat à gauche, et le passe à droite.

## Exemples

Pour cette série d'exemples, nous allons utiliser le module String d'Elixir.

- Tokenize String (en vrac)

```elixir
iex> "Elixir rocks" |> String.split()
["Elixir", "pierres"]
```

- Mettez en majuscule tous les mots-clés

```Elixir
iex> "Elixir rocks" |> String.upcase() |> String.split()
["ÉLIXIR", "PIERRES"]
```

- Vérification de la fin

```Elixir
iex> "élixir" |> String.ends_with ?("ixir")
true
```

## Meilleures pratiques

Si l'arité d'une fonction est supérieure à 1, veillez à utiliser des parenthèses.
Cela n'a pas beaucoup d'importance pour Elixir, mais cela en a pour les autres programmeurs qui pourraient mal interpréter votre code.
En revanche, c'est important pour l'opérateur pipe.
Par exemple, si nous prenons notre troisième exemple, et que nous enlevons les parenthèses de `String.ends_with?/2`, nous obtenons l'avertissement suivant.

```elixir
iex> "élixir" |> Chaîne.finit_par ? "ixir"
Attention : les parenthèses sont obligatoires lorsque l'on utilise un appel de fonction.
Par exemple :

  foo 1 |> bar 2 |> baz 3

est ambigu et doit être écrit comme suit

  foo(1) |> bar(2) |> baz(3)

true
```
