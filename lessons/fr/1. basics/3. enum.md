Un ensemble d'algorithmes pour énumérer sur des énumérables.

# Vue d'ensemble

Le module `Enum` comprend plus de 70 fonctions pour travailler avec des énumérables.
Toutes les collections dont nous avons entendu parler dans la [leçon précédente](/fr/lessons/basics/collections), à l'exception des tuples, sont des énumérables.

Cette leçon ne couvrira qu'un sous-ensemble des fonctions disponibles, mais nous pouvons les examiner nous-mêmes.
Faisons une petite expérience en IEx.

```elixir
iex> Enum.__info__(:functions) |> Enum.each(fn({function, arity}) ->
...> IO.puts "#{fonction}/#{arity}"
...> end)
tous?/1
tous?/2
quelconque?/1
quelconque?/2
at/2
à/3
...
```

En utilisant ceci, il est clair que nous avons une grande quantité de fonctionnalités, et ce pour une raison claire.
L'énumération est au cœur de la programmation fonctionnelle, et combinée avec d'autres avantages d'Elixir, elle peut être incroyablement puissante pour les développeurs.

# Fonctions communes

Pour une liste complète des fonctions, consultez la documentation officielle [`Enum`](https://hexdocs.pm/elixir/Enum.html) ; pour une énumération paresseuse, utilisez le module [`Stream`](https://hexdocs.pm/elixir/Stream.html).

## all ?

Quand on utilise `all?/2`, et la plupart de `Enum`, on fournit une fonction à appliquer aux éléments de notre collection.
Dans le cas de `all?/2`, la collection entière doit être évaluée à `true` sinon `false` sera retourné :

```elixir
iex> Enum.all ?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 3 end)
false
iex> Enum.all ?(["foo", "bar", "hello"], fn(s) -> String.length(s) > 1 end)
true
```

## any ?

Contrairement à ce qui précède, `any?/2` renvoie `true` si au moins un élément est évalué à `true` :

```elixir
iex> Enum.any ?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 5 end)
true
```

## chunk_every

Si vous avez besoin de diviser votre collection en groupes plus petits, `chunk_every/2` est la fonction que vous recherchez probablement :

```elixir
iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]
```

Il existe quelques options pour `chunk_every/4` mais nous ne les détaillerons pas, consultez [la documentation officielle de cette fonction] (https://hexdocs.pm/elixir/Enum.html#chunk_every/4) pour en savoir plus.

## chunk_by

Si nous avons besoin de regrouper notre collection en se basant sur autre chose que la taille, nous pouvons utiliser la fonction `chunk_by/2`.
Elle prend un énumérable donné et une fonction, et lorsque le retour de cette fonction change, un nouveau groupe est lancé et commence la création du suivant.
Dans les exemples ci-dessous, chaque chaîne de la même longueur est regroupée jusqu'à ce que nous rencontrions une nouvelle chaîne d'une nouvelle longueur :

```elixir
iex> Enum.chunk_by(["one", "two", "three", "four", "five"], fn(x) -> String.length(x) end)
[["un", "deux"], ["trois"], ["quatre", "cinq"]]
iex> Enum.chunk_by(["one", "two", "three", "four", "five", "six"], fn(x) -> String.length(x) end)
[["un", "deux"], ["trois"], ["quatre", "cinq"], ["six"]]
```

## map_every

Parfois, le découpage en morceaux d'une collection n'est pas suffisant pour répondre exactement à nos besoins.
Si c'est le cas, `map_every/3` peut être très utile pour atteindre tous les `nièmes` éléments, en atteignant toujours le premier :

```elixir
# Appliquer la fonction tous les trois éléments
iex> Enum.map_every([1, 2, 3, 4, 5, 6, 7, 8], 3, fn x -> x + 1000 end)
[1001, 2, 3, 1004, 5, 6, 1007, 8]
```

## each

Il peut être nécessaire d'itérer sur une collection sans produire une nouvelle valeur, dans ce cas on utilise `each/2` :

```elixir
iex> Enum.each(["one", "two", "three"], fn(s) -> IO.puts(s) end)
un
deux
trois
:ok
```

__Note__ : La fonction `each/2` renvoie bien l'atome `:ok`.

## map

Pour appliquer notre fonction à chaque élément et produire une nouvelle collection, regardez la fonction `map/2` :

```elixir
iex> Enum.map([0, 1, 2, 3], fn(x) -> x - 1 end)
[-1, 0, 1, 2]
```

## min

`min/1` trouve la valeur minimale dans la collection :

```elixir
iex> Enum.min([5, 3, 0, -1])
-1
```

`min/2` fait la même chose, mais au cas où l'énumérable est vide, il nous permet de spécifier une fonction pour produire la valeur minimale.

```elixir
iex> Enum.min([], fn -> :foo end)
:foo
```

## max

`max/1` renvoie la valeur maximale de la collection :

```elixir
iex> Enum.max([5, 3, 0, -1])
5
```

`max/2` est à `max/1` ce que `min/2` est à `min/1` :

```elixir
iex> Enum.max([], fn -> :bar end)
:bar
```

## filter

La fonction `filter/2` nous permet de filtrer la collection pour n'inclure que les éléments qui valent `vrai` en utilisant la fonction fournie.

```elixir
iex> Enum.filter([1, 2, 3, 4], fn(x) -> rem(x, 2) == 0 end)
[2, 4]
```

## reduce

Avec `reduce/3`, nous pouvons distiller notre collection en une seule valeur.
Pour ce faire, nous fournissons un accumulateur optionnel (`10` dans cet exemple) qui sera passé à notre fonction ; si aucun accumulateur n'est fourni, le premier élément de l'énumérable est utilisé :

```elixir
iex> Enum.reduce([1, 2, 3], 10, fn(x, acc) -> x + acc end)
16

iex> Enum.reduce([1, 2, 3], fn(x, acc) -> x + acc end)
6

iex> Enum.reduce([ "a", "b", "c"], "1", fn(x,acc)-> x <> acc end)
"cba1"
```

## sort

Le tri de nos collections est rendu facile avec non pas une, mais deux fonctions de tri.

`sort/1` utilise le [term ordering](http://erlang.org/doc/reference_manual/expressions.html#term-comparisons) d'Erlang pour déterminer l'ordre de tri :

```elixir
iex> Enum.sort([5, 6, 1, 3, -1, 4])
[-1, 1, 3, 4, 5, 6]

iex> Enum.sort([:foo, "bar", Enum, -1, 4])
[-1, 4, Enum, :foo, "bar"]
```

Alors que `sort/2` nous permet de fournir notre propre fonction de tri :

```elixir
# avec notre fonction
iex> Enum.sort([%{:val => 4}, %{:val => 1}], fn(x, y) -> x[:val] > y[:val] end)
[%{val : 4}, %{val : 1}]

# sans
iex> Enum.sort([%{:count => 4}, %{:count => 1}])
[%{count : 1}, %{count : 4}]]
```

Par commodité, `sort/2` nous permet de passer `:asc` ou `:desc` comme fonction de tri :

```elixir
Enum.sort([2, 3, 1], :desc)
[3, 2, 1]
```

## uniq

Nous pouvons utiliser `uniq/1` pour supprimer les doublons de nos énumérables :

```elixir
iex> Enum.uniq([1, 2, 3, 2, 1, 1, 1, 1, 1, 1])
[1, 2, 3]
```

## uniq_by

`uniq_by/2` supprime également les doublons des énumérables, mais elle nous permet de fournir une fonction pour effectuer la comparaison d'unicité.

```elixir
iex> Enum.uniq_by([%{x : 1, y : 1}, %{x : 2, y : 1}, %{x : 3, y : 3}], fn coord -> coord.y end)
[%{x : 1, y : 1}, %{x : 3, y : 3}]]
```

# Enum utilisant l'opérateur de capture (&)
De nombreuses fonctions du module Enum d'Elixir prennent des fonctions anonymes en argument pour travailler avec chaque itérable de l'énumérable qui est passé.

Ces fonctions anonymes sont souvent écrites en raccourci à l'aide de l'opérateur de capture (&).

Voici quelques exemples qui montrent comment l'opérateur de capture peut être mis en œuvre avec le module Enum.
Chaque version est fonctionnellement équivalente.

## Utilisation de l'opérateur de capture avec une fonction anonyme

Voici un exemple typique de la syntaxe standard lors du passage d'une fonction anonyme à `Enum.map/2`.

```elixir
iex> Enum.map([1,2,3], fn nombre -> nombre + 3 end)
[4, 5, 6]
```

Maintenant, nous implémentons l'opérateur de capture (&) ; nous capturons chaque itérable de la liste de nombres ([1,2,3]) et assignons chaque itérable à la variable &1 au fur et à mesure qu'elle est passée par la fonction de mappage.

```elixir
iex> Enum.map([1,2,3], &(&1 + 3))
[4, 5, 6]
```

On peut encore remanier cette fonction pour assigner la fonction anonyme précédente comportant l'opérateur Capture à une variable et l'appeler à partir de la fonction `Enum.map/2`.

```elixir
iex> plus_trois = &(&1 + 3)
iex> Enum.map([1,2,3], plus_trois)
[4, 5, 6]
```

## Utilisation de l'opérateur de capture avec une fonction nommée
Tout d'abord, nous créons une fonction nommée et l'appelons dans la fonction anonyme définie dans `Enum.map/2`.

```elixir
defmodule Additionner faire
  def plus_trois(nombre), do : nombre + 3
end

iex> Enum.map([1,2,3], fn nombre -> Ajout.plus_trois(nombre) end)
[4, 5, 6]
```

Ensuite, nous pouvons refactorer pour utiliser l'opérateur Capture.

```elixir
iex> Enum.map([1,2,3], &Adding.plus_three(&1))
[4, 5, 6]
```

Pour la syntaxe la plus succincte, nous pouvons appeler directement la fonction nommée sans capturer explicitement la variable.

```elixir
iex> Enum.map([1,2,3], &Adding.plus_three/1)
[4, 5, 6]
```
