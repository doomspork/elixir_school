Chaînes de caractères, listes de caractères, graphèmes et points de code.

## Chaînes de caractères

Les chaînes de caractères Elixir ne sont rien d'autre qu'une séquence d'octets.
Regardons un exemple :

```elixir
iex> string = <<104,101,108,108,111>>
"bonjour"
iex> string <> <<0>>
<<104, 101, 108, 108, 111, 0>>
```

En concaténant la chaîne de caractères avec l'octet `0`, IEx affiche la chaîne de caractères comme un binaire car ce n'est plus une chaîne de caractères valide.
Cette astuce peut nous aider à visualiser les octets sous-jacents de n'importe quelle chaîne.

> NOTE : En utilisant la syntaxe << >>, nous disons au compilateur que les éléments à l'intérieur de ces symboles sont des octets.

## Charlists

En interne, les chaînes de caractères Elixir sont représentées par une séquence d'octets plutôt que par un tableau de caractères.
Elixir dispose également d'un type char list (liste de caractères).
Les chaînes Elixir sont entourées de guillemets doubles, tandis que les listes de caractères sont entourées de guillemets simples.

Quelle est la différence ? Chaque valeur dans une charlist est le point de code Unicode d'un caractère alors que dans un binaire, les points de code sont codés en UTF-8.
Voyons cela de plus près :

```elixir
iex> 'hełło' (il)
[104, 101, 322, 322, 111]
iex> "hełło" <> <<0>>
<<104, 101, 197, 130, 197, 130, 111, 0>>
```

`322` est le codepoint Unicode pour ł mais il est codé en UTF-8 comme les deux octets `197`, `130`.

Vous pouvez obtenir le point de code d'un caractère en utilisant `?`.

```elixir
iex> ?Z
90
```

Cela vous permet d'utiliser la notation `?Z` plutôt que 'Z' pour un symbole.

Lorsque nous programmons en Elixir, nous utilisons généralement des chaînes de caractères, et non des listes de caractères.
Le support des listes de caractères est principalement inclus parce qu'il est nécessaire pour certains modules Erlang.

Pour plus d'informations, voir le [`Getting Started Guide`] officiel (http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html).

## Graphemes et Codepoints

Les points de code sont de simples caractères Unicode qui sont représentés par un ou plusieurs octets, selon le codage UTF-8.
Les caractères qui ne font pas partie du jeu de caractères ASCII américain seront toujours encodés sur plus d'un octet.
Par exemple, les caractères latins avec un tilde ou des accents (`á, ñ, è`) sont généralement encodés sur deux octets.
Les caractères des langues asiatiques sont souvent codés sur trois ou quatre octets.
Les graphèmes sont composés de plusieurs points de code qui sont rendus comme un seul caractère.

Le module String fournit déjà deux fonctions pour les obtenir, `graphemes/1` et `codepoints/1`.
Prenons un exemple :

```elixir
iex> string = "\u0061\u0301"
"á"

iex> String.codepoints string
["a", "́"]

iex> String.graphemes string
["á"]
```

## Fonctions des chaînes de caractères

Passons en revue certaines des fonctions les plus importantes et les plus utiles du module String.
Cette leçon ne couvrira qu'un sous-ensemble des fonctions disponibles.
Pour voir un ensemble complet de fonctions, visitez la documentation officielle de [`String`](https://hexdocs.pm/elixir/String.html).

### length/1

Retourne le nombre de graphèmes dans la chaîne.

```elixir
iex> String.length "Bonjour"
5
```

### replace/3

Renvoie une nouvelle chaîne de caractères remplaçant le motif actuel de la chaîne par une nouvelle chaîne de remplacement.

```elixir
iex> String.replace("Bonjour", "e", "a")
"Hallo"
```

### duplicate/2

Renvoie une nouvelle chaîne répétée n fois.

```elixir
iex> String.duplicate("Oh my ", 3)
"Oh mon Oh mon Oh mon Oh mon "
```

### split/2

Retourne une liste de chaînes de caractères séparées par un motif.

```elixir
iex> String.split("Hello World", " ")
["Bonjour", "Monde"]
```

## Exercice

Faisons un exercice simple pour montrer que nous sommes prêts à utiliser les chaînes de caractères !

### Anagrammes

A et B sont considérés comme des anagrammes s'il existe un moyen de réarranger A ou B pour les rendre égaux.
Par exemple :

+ A = super
+ B = perus

Si nous réarrangeons les caractères de la chaîne A, nous pouvons obtenir la chaîne B, et vice versa.

Alors, comment pouvons-nous vérifier si deux chaînes sont des anagrammes en Elixir ?  La solution la plus simple est de trier les graphèmes de chaque chaîne par ordre alphabétique, puis de vérifier si les deux listes sont égales.
Essayons cela :

```elixir
defmodule Anagramme do
  def anagrammes ?(a, b) when is_binary(a) and is_binary(b) do
    sort_string(a) == sort_string(b)
  end

  def sort_string(string) do
    chaîne
    |> Chaîne.minuscule()
    |> Chaîne.graphèmes()
    |> Enum.sort()
  end
fin
```

Regardons d'abord `anagrammes?/2`.
Nous vérifions si les paramètres que nous recevons sont des binaires ou non.
C'est la façon dont nous vérifions si un paramètre est une chaîne en Elixir.

Ensuite, nous appelons une fonction qui ordonne la chaîne par ordre alphabétique.
Elle convertit d'abord la chaîne en minuscules, puis utilise `String.graphemes/1` pour obtenir une liste des graphèmes de la chaîne.
Enfin, elle envoie cette liste dans `Enum.sort/1`.
C'est assez simple, non ?

Vérifions la sortie sur iex :

```elixir
iex> Anagram.anagrammes ?("Hello", "ohell")
true

iex> Anagram.anagrammes ?("María", "íMara")
vrai

iex> Anagramme.anagrammes ?(3, 5)
** (FunctionClauseError) aucune clause de fonction correspondante dans Anagram.anagrammes?/2

    Les arguments suivants ont été donnés à Anagram.anagrams?/2 :

        # 1
        3

        # 2
        5

    iex:11 : Anagramme.anagrammes?/2
```

Comme vous pouvez le voir, le dernier appel à `anagrams?` a provoqué une FunctionClauseError.
Cette erreur nous dit qu'il n'y a pas de fonction dans notre module qui réponde au modèle de réception de deux arguments non binaires, et c'est exactement ce que nous voulons, recevoir juste deux chaînes de caractères, et rien de plus.
