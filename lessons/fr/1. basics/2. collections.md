Listes, tuples, listes de mots-clés et cartes.

## Listes

Les listes sont de simples collections de valeurs qui peuvent inclure plusieurs types ; les listes peuvent également inclure des valeurs non uniques :

```elixir
iex> [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
```

Elixir implémente les collections de listes comme des listes liées.
Cela signifie que l'accès à la longueur de la liste est une opération qui s'exécutera en temps linéaire (`O(n)`).
Pour cette raison, il est généralement plus rapide de prépendre que d'ajouter :

```elixir
iex> list = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
# Prepending (fast)
iex> ["π" | list]
["π", 3.14, :pie, "Apple"]
# Appending (slow)
iex> list ++ ["Cherry"]
[3.14, :pie, "Apple", "Cherry"]
```

### Concaténation de listes

La concaténation de listes utilise l'opérateur `++/2` :

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

Une remarque sur le format du nom (`++/2`) utilisé ci-dessus :
En Elixir (et en Erlang, sur lequel Elixir est construit), le nom d'une fonction ou d'un opérateur a deux composantes : le nom que vous lui donnez (ici `++`) et son _arité_.
L'arité est un élément essentiel pour parler du code Elixir (et Erlang).
C'est le nombre d'arguments que prend une fonction donnée (deux, dans ce cas).
L'arité et le nom donné sont combinés avec un slash. Nous en reparlerons plus tard ; cette connaissance vous aidera à comprendre la notation pour l'instant.

### Soustraction de liste

Le support pour la soustraction est fourni par l'opérateur `--/2` ; il est sûr de soustraire une valeur manquante :

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

Faites attention aux valeurs dupliquées.
Pour chaque élément à droite, la première occurrence de cet élément est supprimée à gauche :

```elixir
iex> [1,2,2,3,2,3] -- [1,2,3,2]
[2, 3]
```

**Remarque : la soustraction de listes utilise la [comparaison stricte](/fr/lessons/basics/basics#comparison) pour faire correspondre les valeurs. Par exemple :

```elixir
iex> [2] -- [2.0]
[2]
iex> [2.0] -- [2.0]
[]
```

### Tête et queue de liste

Lorsque vous utilisez des listes, il est courant de travailler avec la tête et la queue d'une liste.
La tête est le premier élément de la liste, tandis que la queue est une liste contenant les autres éléments.
Elixir fournit deux fonctions utiles, `hd` et `tl`, pour travailler avec ces parties :

```elixir
iex> hd [3.14, :pie, "Apple"]
3.14
iex> tl [3.14, :pie, "Apple"]
[:pie, "Apple"]
```

En plus des fonctions mentionnées ci-dessus, vous pouvez utiliser [pattern matching](/fr/lessons/basics/pattern_matching) et l'opérateur cons `|` pour diviser une liste en tête et queue. Nous en apprendrons plus sur ce modèle dans les leçons suivantes :

```elixir
iex> [head | tail] = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
iex> head
3.14
iex> tail
[:pie, "Apple"]
```

## Tuples

Les tuples sont similaires aux listes, mais sont stockés de manière contiguë en mémoire.
Cela rend l'accès à leur longueur rapide mais la modification coûteuse ; le nouveau tuple doit être entièrement copié en mémoire.
Les tuples sont définis avec des accolades :

```elixir
iex> {3.14, :pie, "Apple"}
{3.14, :pie, "Apple"}
```

Il est courant d'utiliser des tuples comme mécanisme pour renvoyer des informations supplémentaires à partir de fonctions ; l'utilité de ce mécanisme sera plus évidente lorsque nous aborderons le [filtrage] (/fr/lessons/basics/pattern_matching) :

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## Listes de mots-clés

Les listes de mots-clés et les maps sont les collections associatives d'Elixir.
En Elixir, une liste de mots-clés est une liste spéciale de tuples à deux éléments dont le premier élément est un atome ; elle partage les performances avec les listes :

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

Les trois caractéristiques des listes de mots-clés soulignent leur importance :

+ Les clés sont des atomes.
+ Les clés sont ordonnées.
+ Les clés ne doivent pas nécessairement être uniques.

Pour ces raisons, les listes de mots-clés sont le plus souvent utilisées pour passer des options aux fonctions.

## Map

Dans Elixir, les maps sont le magasin de clés-valeurs par excellence.
Contrairement aux listes de mots-clés, elles autorisent des clés de tout type et ne sont pas ordonnées.
Vous pouvez définir une map avec la syntaxe `%{}` :

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

Depuis Elixir 1.2, les variables sont autorisées en tant que clés de carte :

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

Si un doublon est ajouté à une carte, il remplacera la valeur précédente :

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

Comme nous pouvons le voir dans le résultat ci-dessus, il existe une syntaxe spéciale pour les cartes ne contenant que des clés atomiques :

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```

En outre, il existe une syntaxe spéciale que vous pouvez utiliser avec les clés atomiques :

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> map.hello
"world"
```

Une autre propriété intéressante des cartes est qu'elles fournissent leur propre syntaxe pour les mises à jour (note : ceci crée une nouvelle carte) :

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{map | foo: "baz"}
%{foo: "baz", hello: "world"}
```

**Note** : cette syntaxe ne fonctionne que pour mettre à jour une clé qui existe déjà dans la map ! Si la clé n'existe pas, une `KeyError` sera levée.

Pour créer une nouvelle clé, utilisez plutôt [`Map.put/3`](https://hexdocs.pm/elixir/Map.html#put/3)

```elixir
iex> map = %{hello: "world"}
%{hello: "world"}
iex> %{map | foo: "baz"}
** (KeyError) key :foo not found in: %{hello: "world"}
    (stdlib) :maps.update(:foo, "baz", %{hello: "world"})
    (stdlib) erl_eval.erl:259: anonymous fn/2 in :erl_eval.expr/5
    (stdlib) lists.erl:1263: :lists.foldl/3
iex> Map.put(map, :foo, "baz")
%{foo: "baz", hello: "world"}
```