### Spécifications et types

Dans cette leçon, nous allons apprendre la syntaxe `@spec` et `@type`.

`@spec` est plus un complément de syntaxe pour écrire de la documentation qui pourrait être analysée par des outils.

`@type` nous aide à écrire un code plus lisible et plus facile à comprendre.

## Introduction

Il n'est pas rare que vous souhaitiez décrire l'interface de votre fonction.
Vous pourriez utiliser l'annotation [@doc](/fr/lessons/basics/documentation), mais ce ne sont que des informations pour les autres développeurs qui ne sont pas vérifiées à la compilation.
À cette fin, Elixir a l'annotation `@spec` pour décrire la spécification d'une fonction qui sera vérifiée par le compilateur.

Cependant, dans certains cas, la spécification va être assez grande et compliquée.
Si vous souhaitez réduire la complexité, vous pouvez introduire une définition de type personnalisée.
Elixir a l'annotation `@type` pour cela.
D'un autre côté, Elixir est toujours un langage dynamique.
Cela signifie que toutes les informations sur un type seront ignorées par le compilateur, mais pourraient être utilisées par d'autres outils.

## Spécification

Si vous avez de l'expérience avec Java, vous pouvez penser à la spécification comme une `interface`.
La spécification définit ce que devrait être le type des paramètres d'une fonction et de sa valeur de retour.

Pour définir les types d'entrée et de sortie, on utilise la directive `@spec` placée juste avant la définition de la fonction et prenant comme `params` le nom de la fonction, une liste de types de paramètres, et après `::` le type de la valeur de retour.

Prenons un exemple :

```elixir
@spec sum_product(integer) : : integer
def sum_product(a) do
  [1, 2, 3]
  |> Enum.map(fn el -> el * a end)
  |> Enum.sum()
end
```

Tout semble correct et lorsque nous l'appelons, un résultat valide sera retourné, mais la fonction `Enum.sum` retourne un `number`, et non un `integer` comme nous l'attendions dans `@spec`.
Cela pourrait être une source de bugs ! Il existe des outils comme Dialyzer pour effectuer une analyse statique du code qui nous aide à trouver ce type de bogue.
Nous en parlerons dans une autre leçon.

## Types personnalisés

Ecrire des spécifications c'est bien, mais parfois nos fonctions travaillent avec des structures de données plus complexes que de simples nombres ou collections.
Dans le cas de cette définition dans `@spec`, elle pourrait être difficile à comprendre et/ou à modifier pour les autres développeurs.
Parfois, les fonctions doivent prendre en compte un grand nombre de paramètres ou retourner des données complexes.
Une longue liste de paramètres est l'une des nombreuses mauvaises odeurs potentielles dans le code d'une personne.
Dans les langages orientés objet comme Ruby ou Java, nous pouvons facilement définir des classes qui nous aident à résoudre ce problème.
Elixir n'a pas de classes, mais comme il est facile à étendre, nous pouvons définir nos propres types.

Dès le départ, Elixir contient quelques types de base comme `integer` ou `pid`.
Vous pouvez trouver la liste complète des types disponibles dans la [documentation](https://hexdocs.pm/elixir/typespecs.html#types-and-their-syntax).

### Définir un type personnalisé

Modifions notre fonction `sum_times` et introduisons quelques paramètres supplémentaires :

```elixir
@spec sum_times(integer, %Examples{first : integer, last : integer}) : : integer
def sum_times(a, params) do
  for i <- params.first..params.last do
    i
  end
  |> Enum.map(fn el -> el * a end)
  |> Enum.sum()
  |> round
end
```

Nous avons introduit une structure dans le module `Examples` qui contient deux champs - `first` et `last`.
Il s'agit d'une version simplifiée de la structure du module `Range`.
Pour plus d'informations sur les `structs`, veuillez consulter la section sur les [modules](/fr/lessons/basics/modules#structs).
Imaginons que nous ayons besoin d'une spécification avec une structure `Examples` à plusieurs endroits.
Il serait ennuyeux d'écrire des spécifications longues et complexes et cela pourrait être une source de bogues.
Une solution à ce problème est `@type`.

Elixir a trois directives pour les types :

  - `@type` - type simple et public.
La structure interne du type est publique.
  - `@typep` - le type est privé et ne peut être utilisé que dans le module où il est défini.
  - `@opaque` - le type est public, mais sa structure interne est privée.

Définissons notre type :

```elixir
defmodule Exemples do
  defstruct first : nil, last : nil

  @type t(first, last) : : %Examples{first : first, last : last}

  @type t : : %Exemples{first : integer, last : integer}
end
```

Nous avons déjà défini le type `t(first, last)`, qui est une représentation de la structure `%Examples{first : first, last : last}`.
A ce stade, nous voyons que les types peuvent prendre des paramètres, mais nous avons également défini le type `t` et cette fois, c'est une représentation de la structure `%Examples{first : integer, last : integer}`.

Quelle est la différence ? Le premier représente la structure `Examples` dans laquelle les deux clés peuvent être de n'importe quel type.
La seconde représente la structure dans laquelle les clés sont des `integers`.
Cela signifie que le code qui ressemble à ceci :

```elixir
@spec sum_times(integer, Examples.t()) : : integer
def sum_times(a, params) do
  pour i <- params.first..params.last do
    i
  end
  |> Enum.map(fn el -> el * a end)
  |> Enum.sum()
  |> round
fin
```

Est égal à un code comme :

```elixir
@spec sum_times(integer, Examples.t(integer, integer)) : : integer
def sum_times(a, params) do
  for i <- params.first..params.last do
    i
  end
  |> Enum.map(fn el -> el * a end)
  |> Enum.sum()
  |> round
end
```

### Documentation des types

Le dernier élément dont nous devons parler est la façon de documenter nos types.
Comme nous l'avons vu dans la leçon [documentation](/fr/lessons/basics/documentation), nous avons les annotations `@doc` et `@moduledoc` pour créer de la documentation pour les fonctions et les modules.
Pour documenter nos types, nous pouvons utiliser `@typedoc` :

```elixir
defmodule Exemples do
  @typedoc """
      Type qui représente la structure Examples avec :first comme entier et :last comme entier.
  """
  @type t : : %Exemples{first : entier, last : entier}
end
```

La directive `@typedoc` est similaire à `@doc` et `@moduledoc`.
