### OTP Distribution

Nous pouvons exécuter nos applications Elixir sur un ensemble de nœuds différents répartis sur un seul hôte ou sur plusieurs hôtes.

Elixir nous permet de communiquer entre ces nœuds par le biais de quelques mécanismes différents que nous allons présenter dans cette leçon.

## Communication entre les nœuds

Elixir fonctionne sur la VM Erlang, ce qui signifie qu'il a accès à la puissante [fonctionnalité de distribution] d'Erlang (http://erlang.org/doc/reference_manual/distributed.html).

> Un système Erlang distribué consiste en un certain nombre de systèmes d'exécution Erlang communiquant entre eux.
Chacun de ces systèmes d'exécution est appelé un noeud.

Un nœud est un système d'exécution Erlang auquel on a donné un nom.
Nous pouvons démarrer un noeud en ouvrant une session `iex` et en la nommant :

```bash
iex --sname alex@localhost
iex(alex@localhost)>
```

Ouvrons un autre noeud dans une autre fenêtre de terminal :

```bash
iex --sname kate@localhost
iex(kate@localhost)>
```

Ces deux noeuds peuvent s'envoyer des messages en utilisant `Node.spawn_link/2`.

### Communiquer avec Node.spawn_link/2

Cette fonction prend deux arguments :
* Le nom du nœud auquel vous voulez vous connecter.
* La fonction qui doit être exécutée par le processus distant s'exécutant sur ce noeud.

Elle établit la connexion avec le nœud distant et exécute la fonction donnée sur ce nœud, en renvoyant le PID du processus lié.

Définissons un module, `Kate`, dans le noeud `kate` qui sait comment présenter Kate, la personne :

```elixir
iex(kate@localhost)> defmodule Kate do
...(kate@localhost)> def say_name do
...(kate@localhost)> IO.puts "Bonjour, je m'appelle Kate".
...(kate@localhost)> end
...(kate@localhost)> end
```

#### Envoi de messages

Maintenant, nous pouvons utiliser [`Node.spawn_link/2`](https://hexdocs.pm/elixir/Node.html#spawn_link/2) pour que le noeud `alex` demande au noeud `kate` d'appeler la fonction `say_name/0` :

```elixir
iex(alex@localhost)> Node.spawn_link(:kate@localhost, fn -> Kate.say_name end)
Bonjour, mon nom est Kate
#PID<10507.132.0>
```

#### Une note sur les E/S et les nœuds

Remarquez que, bien que `Kate.say_name/0` soit exécuté sur le noeud distant, c'est le noeud local, ou appelant, qui reçoit la sortie `IO.puts`.
C'est parce que le noeud local est le **meneur du groupe**.
La VM Erlang gère les E/S via des processus.
Cela nous permet d'exécuter des tâches d'E/S, comme `IO.puts`, sur des noeuds distribués.
Ces processus distribués sont gérés par le chef de groupe du processus d'E/S.
Le chef de groupe est toujours le noeud qui génère le processus.
Ainsi, puisque notre noeud `alex` est celui à partir duquel nous avons appelé `spawn_link/2`, ce noeud est le chef de groupe et la sortie de `IO.puts` sera dirigée vers le flux de sortie standard de ce noeud.

#### Répondre aux messages

Que faire si nous voulons que le noeud qui reçoit le message envoie une réponse à l'expéditeur ? Nous pouvons utiliser une simple configuration `receive/1` et [`send/3`] (https://hexdocs.pm/elixir/Process.html#send/3) pour accomplir exactement cela.

Nous allons demander à notre noeud `alex` de créer un lien vers le noeud `kate` et de donner au noeud `kate` une fonction anonyme à exécuter.
Cette fonction anonyme va écouter la réception d'un tuple particulier décrivant un message et le PID du noeud `alex`.
Elle répondra à ce message en renvoyant un message au PID du noeud `alex` :

```elixir
iex(alex@localhost)> pid = Node.spawn_link :kate@localhost, fn ->
...(alex@localhost)> receive do
...(alex@localhost)> {:hi, alex_node_pid} -> send alex_node_pid, :sup ?
...(alex@localhost)> end
...(alex@localhost)> end
#PID<10467.112.0>
iex(alex@localhost)> pid
#PID<10467.112.0>
iex(alex@localhost)> send(pid, {:hi, self()})
{:hi, #PID<0.106.0>}
iex(alex@localhost)> flush()
:sup ?
:ok
```

#### Une note sur la communication entre des noeuds sur différents réseaux

Si vous voulez envoyer des messages entre des noeuds situés sur des réseaux différents, nous devons démarrer les noeuds nommés avec un cookie partagé :

```bash
iex --sname alex@localhost --cookie secret_token
```

```bash
iex --sname kate@localhost --cookie secret_token
```

Seuls les noeuds démarrés avec le même `cookie` pourront se connecter avec succès les uns aux autres.

#### Limites de Node.spawn_link/2

Bien que `Node.spawn_link/2` illustre les relations entre les noeuds et la manière dont nous pouvons envoyer des messages entre eux, ce n'est _pas_ vraiment le bon choix pour une application qui fonctionnera sur des noeuds distribués.
`Node.spawn_link/2` génère des processus en isolation, c'est-à-dire des processus qui ne sont pas supervisés.
Si seulement il y avait un moyen de créer des processus supervisés et asynchrones _à travers les noeuds_...

## Tâches distribuées

Les [Tâches distribuées] (https://hexdocs.pm/elixir/master/Task.html#module-distributed-tasks) nous permettent d'engendrer des tâches supervisées à travers les noeuds.
Nous allons construire une application superviseur simple qui exploite les tâches distribuées pour permettre aux utilisateurs de discuter entre eux via une session `iex`, à travers des noeuds distribués.

### Définition de l'application superviseur

Générez votre application :

```shell
mix new chat --sup
```

### Ajouter le superviseur de tâches à l'arbre de supervision

Un superviseur de tâches supervise dynamiquement les tâches.
Il est démarré sans enfant, souvent _sous_ son propre superviseur, et peut être utilisé plus tard pour superviser un nombre quelconque de tâches.

Nous allons ajouter un superviseur de tâches à l'arbre de supervision de notre application et le nommer `Chat.TaskSupervisor`.

```elixir
# lib/chat/application.ex
defmodule Chat.Application do
  @moduledoc false

  utiliser l'application

  def start(_type, _args) do
    enfants = [
      {Task.Supervisor, nom : Chat.TaskSupervisor}
    ]

    opts = [strategy : :one_for_one, name : Chat.Supervisor]
    Supervisor.start_link(children, opts)
  fin
end
```

Nous savons maintenant que, quel que soit l'endroit où notre application est lancée sur un noeud donné, le `Chat.Supervisor` fonctionne et est prêt à superviser les tâches.

### Envoi de messages avec des tâches supervisées

Nous allons démarrer les tâches supervisées avec la fonction [`Task.Supervisor.async/5`](https://hexdocs.pm/elixir/master/Task.Supervisor.html#async/5).

Cette fonction doit prendre quatre arguments :

* Le superviseur que nous voulons utiliser pour superviser la tâche.
Il peut être passé comme un tuple de `{SupervisorName, remote_node_name}` afin de superviser la tâche sur le noeud distant.
* Le nom du module sur lequel nous voulons exécuter une fonction.
* Le nom de la fonction que nous voulons exécuter
* Tout argument qui doit être fourni à cette fonction.

Vous pouvez passer un cinquième argument, facultatif, décrivant les options d'arrêt.
Nous ne nous en soucierons pas ici.

Notre application de chat est assez simple.
Elle envoie des messages aux noeuds distants et les noeuds distants répondent à ces messages en les envoyant par `IO.puts` vers le STDOUT du noeud distant.

Tout d'abord, définissons une fonction, `Chat.receive_message/1`, que nous voulons que notre tâche exécute sur un noeud distant.

```elixir
# lib/chat.ex
defmodule Chat do
  def receive_message(message) do
    IO.puts message
  end
end
```

Ensuite, nous allons apprendre au module `Chat` comment envoyer le message à un noeud distant en utilisant une tâche supervisée.
Nous allons définir une méthode `Chat.send_message/2` qui exécutera ce processus :

```elixir
# lib/chat.ex
defmodule Chat do
  ...

  def send_message(recipient, message) do
    spawn_task(__MODULE__, :receive_message, recipient, [message])
  end

  def spawn_task(module, fun, recipient, args) do
    destinataire
    |> superviseur_à_distance()
    |> Task.Supervisor.async(module, fun, args)
    |> Task.await()
  end

  defp remote_supervisor(recipient) do
    {Chat.TaskSupervisor, destinataire}
  end
end
```

Voyons cela en action.

Dans une fenêtre de terminal, démarrez notre application de chat dans une session nommée `iex`.

```bash
iex --sname alex@localhost -S mix
```

Ouvrez une autre fenêtre de terminal pour démarrer l'application sur un autre noeud nommé :

``bash
iex --sname kate@localhost -S mix
```

Maintenant, depuis le noeud `alex`, nous pouvons envoyer un message au noeud `kate` :

```elixir
iex(alex@localhost)> Chat.send_message(:kate@localhost, "hi")
:ok
```

Passez à la fenêtre `kate` et vous devriez voir le message :

```elixir
iex(kate@localhost)> hi
```

Le noeud `kate` peut répondre au noeud `alex` :

```elixir
iex(kate@localhost)> hi
Chat.send_message(:alex@localhost, "comment allez-vous ?")
:ok
iex(kate@localhost)>
```

Et il apparaîtra dans la session `iex` du noeud `alex` :

```elixir
iex(alex@localhost)> comment allez-vous ?
```

Revoyons notre code et décomposons ce qui se passe ici.

Nous avons une fonction `Chat.send_message/2` qui prend le nom du noeud distant sur lequel nous voulons exécuter nos tâches supervisées et le message que nous voulons envoyer à ce noeud.

Cette fonction appelle notre fonction `spawn_task/4` qui démarre une tâche asynchrone sur le noeud distant avec le nom donné, supervisée par le `Chat.TaskSupervisor` sur ce noeud distant.
Nous savons que le superviseur de tâches portant le nom `Chat.TaskSupervisor` est en cours d'exécution sur ce noeud parce que ce noeud exécute _également_ une instance de notre application de chat et que le `Chat.TaskSupervisor` est démarré dans le cadre de l'arbre de supervision de l'application de chat.

Nous demandons au `Chat.TaskSupervisor` de superviser une tâche qui exécute la fonction `Chat.receive_message` avec comme argument le message qui a été transmis à `spawn_task/4` depuis `send_message/2`.

Ainsi, `Chat.receive_message("hi")` est appelée sur le noeud distant `kate`, provoquant la sortie du message `"hi"`, sur le flux STDOUT de ce noeud.
Dans ce cas, puisque la tâche est supervisée sur le nœud distant, ce nœud est le gestionnaire de groupe pour ce processus d'E/S.

### Répondre aux messages des noeuds distants

Rendons notre application de chat un peu plus intelligente.
Jusqu'à présent, un nombre quelconque d'utilisateurs peuvent exécuter l'application dans une session `iex` nommée et commencer à chatter.
Mais disons qu'il y a un chien blanc de taille moyenne nommé Moebi qui ne veut pas être laissé de côté.
Moebi veut être inclus dans l'application de chat mais malheureusement, il ne sait pas taper, car c'est un chien.
Nous allons donc apprendre à notre module `Chat` à répondre à tous les messages envoyés à un noeud nommé `moebi@localhost` au nom de Moebi.
Peu importe ce que vous dites à Moebi, il répondra par "chicken ?", car son seul désir est de manger du poulet.

Nous allons définir une autre version de notre fonction `send_message/2` qui correspond au motif de l'argument `recipient`.
Si le destinataire est `:moebi@locahost`, nous allons

* Récupérer le nom du noeud actuel en utilisant `Node.self()`.
* Donner le nom du noeud actuel, c'est-à-dire l'expéditeur, à une nouvelle fonction `receive_message_for_moebi/2`, afin que nous puissions envoyer un message _en retour_ à ce noeud.

```elixir
# lib/chat.ex
...
def send_message(:moebi@localhost, message) do
  spawn_task(__MODULE__, :receive_message_for_moebi, :moebi@localhost, [message, Node.self()])
end
```

Ensuite, nous allons définir une fonction `receive_message_for_moebi/2` qui `IO.puts` le message dans le flux STDOUT du noeud `moebi` _et_ renvoie un message à l'expéditeur :

```elixir
# lib/chat.ex
...
def receive_message_for_moebi(message, from) do
  IO.puts message
  send_message(from, "chicken ?")
end
```

En appelant `send_message/2` avec le nom du noeud qui a envoyé le message original (le "noeud expéditeur"), nous demandons au noeud _remote_ de créer une tâche supervisée sur ce noeud expéditeur.

Voyons cela en action.
Dans trois fenêtres de terminal différentes, ouvrez trois nœuds nommés différents :

```bash
iex --sname alex@localhost -S mix
```

```bash
iex --sname kate@localhost -S mix
```

```bash
iex --sname moebi@localhost -S mix
```

Demandons à `alex` d'envoyer un message à `moebi` :

```elixir
iex(alex@localhost)> Chat.send_message(:moebi@localhost, "hi")
poule mouillée ?
:ok
```

Nous pouvons voir que le noeud `alex` a reçu la réponse, `"chicken ?"`.
Si on ouvre le noeud `kate`, on voit qu'aucun message n'a été reçu, puisque ni `alex` ni `moebi` ne lui en ont envoyé un (désolé `kate`).
Et si nous ouvrons la fenêtre du terminal du noeud `moebi`, nous verrons le message que le noeud `alex` a envoyé :

```elixir
iex(moebi@localhost)> bonjour
```

## Tester le code distribué

Commençons par écrire un test simple pour notre fonction `send_message`.

```elixir
# test/chat_test.exs
defmodule ChatTest do
  use ExUnit.Case, async : true
  doctest Chat

  test "send_message" do
    assert Chat.send_message(:moebi@localhost, "hi") == :ok
  end
end
```

Si nous exécutons nos tests via `mix test`, nous voyons qu'ils échouent avec l'erreur suivante :

```elixir
** (exit) exited in : GenServer.call({Chat.TaskSupervisor, :moebi@localhost}, {:start_task, [#PID<0.158.0>, :monitor, {:sophie@localhost, #PID<0.158.0>}, {Chat, :receive_message_for_moebi, ["hi", :sophie@localhost]}], :temporary, nil}, :infinity)
         ** (EXIT) pas de connexion à moebi@localhost
```

Cette erreur est parfaitement logique : nous ne pouvons pas nous connecter à un noeud nommé `moebi@localhost` car il n'existe pas de tel noeud.

Nous pouvons faire passer ce test en effectuant quelques étapes :

* Ouvrez une autre fenêtre de terminal et exécutez le noeud nommé : `iex --sname moebi@localhost -S mix`.
* Exécuter les tests dans le premier terminal via un noeud nommé qui exécute les tests de mixage dans une session `iex` : `iex --sname sophie@localhost -S mix test`.

C'est beaucoup de travail et ce n'est certainement pas un processus de test automatisé.

Il y a deux approches différentes que nous pouvons prendre ici :

1. Exclure conditionnellement les tests qui nécessitent des nœuds distribués, si le nœud nécessaire n'est pas en fonctionnement.
2. Configurer notre application pour éviter de générer des tâches sur des nœuds distants dans l'environnement de test.

Examinons la première approche.

### Exclusion conditionnelle des tests avec des balises

Nous allons ajouter une balise `ExUnit` à ce test :

```elixir
# test/chat_test.exs
defmodule ChatTest do
  use ExUnit.Case, async : true
  doctest Chat

  @tag :distribué
  test "send_message" do
    assert Chat.send_message(:moebi@localhost, "hi") == :ok
  end
end
```

Et nous ajouterons une logique conditionnelle à notre aide de test pour exclure les tests avec de telles balises si les tests ne sont _pas_ exécutés sur un nœud nommé.

```elixir
# test/test_helper.exs
exclure =
  if Node.alive ?, do : [], else : [distribué : true]

ExUnit.start(exclude : exclude)
```

Nous vérifions si le nœud est vivant, c'est-à-dire
si le noeud fait partie d'un système distribué avec [`Node.alive?`](https://hexdocs.pm/elixir/Node.html#alive?/0).
Si ce n'est pas le cas, nous pouvons dire à `ExUnit` de sauter tous les tests avec le tag `distributed : true`.
Sinon, nous lui dirons de n'exclure aucun test.

Maintenant, si nous lançons le bon vieux `mix test`, nous verrons :

```bash
mix test
Exclusion des balises : [distributed : true]

Terminé en 0.02 secondes
1 test, 0 échec, 1 exclusion
```

Et si nous voulons exécuter nos tests distribués, nous devons simplement suivre les étapes décrites dans la section précédente : exécuter le nœud `moebi@localhost` _et_ exécuter les tests dans un nœud nommé via `iex`.

Jetons un coup d'oeil à notre autre approche de test : configurer l'application pour qu'elle se comporte différemment dans différents environnements.

### Configuration de l'application en fonction de l'environnement

La partie de notre code qui indique à `Task.Supervisor` de démarrer une tâche supervisée sur un noeud distant est ici :

```elixir
# app/chat.ex
def spawn_task(module, fun, recipient, args) do
  destinataire
  |> remote_supervisor()
  |> Task.Supervisor.async(module, fun, args)
  |> Task.await()
end

defp remote_supervisor(recipient) do
  {Chat.TaskSupervisor, destinataire}
end
```

`Task.Supervisor.async/5` prend en premier argument le superviseur que nous voulons utiliser.
Si nous passons un tuple de `{SupervisorName, location}`, il va démarrer le superviseur donné sur le noeud distant donné.
Cependant, si nous passons à `Task.Supervisor` un premier argument d'un nom de superviseur, il utilisera ce superviseur pour superviser la tâche localement.

Rendons la fonction `remote_supervisor/1` configurable en fonction de l'environnement.
Dans l'environnement de développement, elle retournera `{Chat.TaskSupervisor, recipient}` et dans l'environnement de test, elle retournera `Chat.TaskSupervisor`.

Nous allons faire cela via des variables d'application.

Créez un fichier, `config/dev.exs`, et ajoutez :

```elixir
# config/dev.exs
utiliser Mix.Config
config :chat, remote_supervisor : fn(recipient) -> {Chat.TaskSupervisor, recipient} end
```

Créez un fichier, `config/test.exs` et ajoutez :

```elixir
# config/test.exs
utilisez Mix.Config
config :chat, remote_supervisor : fn(_recipient) -> Chat.TaskSupervisor end
```

N'oubliez pas de décommenter cette ligne dans `config/config.exs` :

```elixir
utiliser Mix.Config
import_config "#{Mix.env()}.exs"
```

Enfin, nous allons mettre à jour notre fonction `Chat.remote_supervisor/1` pour rechercher et utiliser la fonction stockée dans notre nouvelle variable d'application :

```elixir
# lib/chat.ex
defp remote_supervisor(recipient) do
  Application.get_env(:chat, :remote_supervisor).(destinataire)
end
```

## Conclusion

Les capacités de distribution natives d'Elixir, dont il dispose grâce à la puissance de la VM Erlang, sont l'une des caractéristiques qui en font un outil si puissant.
Nous pouvons imaginer tirer parti de la capacité d'Elixir à gérer le calcul distribué pour exécuter des tâches d'arrière-plan concurrentes, pour prendre en charge des applications à haute performance, pour exécuter des opérations coûteuses - vous l'avez dit.

Cette leçon nous donne une introduction de base au concept de distribution dans Elixir et vous fournit les outils dont vous avez besoin pour commencer à créer des applications distribuées.
En utilisant des tâches supervisées, vous pouvez envoyer des messages à travers les différents nœuds d'une application distribuée.
