### Superviseurs OTP

Les superviseurs sont des processus spécialisés ayant un seul objectif : surveiller d'autres processus.
Ces superviseurs nous permettent de créer des applications tolérantes aux pannes en redémarrant automatiquement les processus enfants lorsqu'ils échouent.

## Configuration

La magie des superviseurs réside dans la fonction `Supervisor.start_link/2`.
En plus de démarrer notre superviseur et ses enfants, elle nous permet de définir la stratégie que notre superviseur utilise pour gérer les processus enfants.

En utilisant la `SimpleQueue` de la leçon [OTP Concurrency](/fr/lessons/advanced/otp_concurrency), commençons :

Créez un nouveau projet en utilisant `mix new simple_queue --sup` pour créer un nouveau projet avec un arbre superviseur.
Le code du module `SimpleQueue` doit aller dans `lib/simple_queue.ex` et le code du superviseur que nous allons ajouter ira dans `lib/simple_queue/application.ex`.

Les enfants sont définis en utilisant une liste, soit une liste de noms de modules :

```elixir
defmodule SimpleQueue.Application do
  utiliser Application

  def start(_type, _args) do
    enfants = [
      SimpleQueue
    ]

    opts = [strategy : :one_for_one, name : SimpleQueue.Supervisor]
    Supervisor.start_link(enfants, opts)
  end
end
```

ou une liste de tuples si vous voulez inclure des options de configuration :

```elixir
defmodule SimpleQueue.Application do
  utiliser Application

  def start(_type, _args) do
    children = [
      {SimpleQueue, [1, 2, 3]}
    ]

    opts = [strategy : :one_for_one, name : SimpleQueue.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

Si nous exécutons `iex -S mix`, nous verrons que notre `SimpleQueue` est automatiquement démarré :

```elixir
iex> SimpleQueue.queue
[1, 2, 3]
```

Si notre processus `SimpleQueue` devait se planter ou être interrompu, notre superviseur le relancerait automatiquement comme si rien ne s'était passé.

### Stratégies

Il y a actuellement trois stratégies de supervision différentes disponibles pour les superviseurs :

+ `:one_for_one` - Ne redémarre que le processus enfant qui a échoué.

+ `:one_for_all` - Redémarre tous les processus enfants en cas d'échec.

+ `:rest_for_one` - Redémarre le processus en échec et tout processus démarré après lui.

## Spécification des enfants

Après que le superviseur ait démarré, il doit savoir comment démarrer/arrêter/redémarrer ses enfants.
Chaque module enfant doit avoir une fonction `child_spec/1` pour définir ces comportements.
Les macros `use GenServer`, `use Supervisor`, et `use Agent` définissent automatiquement cette méthode pour nous (`SimpleQueue` a `use GenServer`, donc nous n'avons pas besoin de modifier le module), mais si vous avez besoin de la définir vous-même `child_spec/1` devrait retourner une carte d'options :

```elixir
def child_spec(opts) do
  %{
    id : SimpleQueue,
    start : {__MODULE__, :start_link, [opts]},
    shutdown : 5_000,
    restart : :permanent,
    type : :worker
  }
end
```

+ `id` - Clé obligatoire.
Utilisée par le superviseur pour identifier la spécification enfant.

+ `start` - Clé requise.
Module/Fonction/Arguments à appeler lors du démarrage par le superviseur.

+ `shutdown` - Clé facultative.
Définit le comportement de l'enfant pendant l'arrêt.
Les options sont :

  + `:brutal_kill` - L'enfant est arrêté immédiatement

  + tout nombre entier positif - temps en millisecondes que le superviseur attendra avant de tuer le processus enfant.
Si le processus est de type `:worker`, la valeur par défaut est 5000.

  + `:infinity` - Le superviseur attendra indéfiniment avant de tuer le processus enfant.
Par défaut pour le type de processus `:supervisor`.
Non recommandé pour le type `:worker`.

+ `restart` - Clé optionnelle.
Il y a plusieurs approches pour gérer les plantages de processus enfant :

  + `:permanent` - L'enfant est toujours redémarré.
Par défaut pour tous les processus

  + `:temporary` - Le processus enfant n'est jamais redémarré.

  + `:transient` - Le processus enfant est redémarré uniquement s'il se termine anormalement.

+ `type` - Clé optionnelle.
Les processus peuvent être soit `:worker`, soit `:supervisor`.
La valeur par défaut est `:worker`.

## DynamicSupervisor

Les superviseurs commencent normalement avec une liste d'enfants à lancer au démarrage de l'application.
Cependant, il arrive que les enfants supervisés ne soient pas connus au moment du démarrage de l'application (par exemple, nous pouvons avoir une application web qui démarre un nouveau processus pour gérer un utilisateur se connectant à notre site).
Dans ces cas, nous voulons un superviseur où les enfants peuvent être lancés à la demande.
Le DynamicSupervisor est utilisé pour gérer ce cas.

Puisque nous ne spécifions pas d'enfants, nous devons seulement définir les options d'exécution pour le superviseur.
Le DynamicSupervisor ne supporte que la stratégie de supervision `:one_for_one` :

```elixir
options = [
  name : SimpleQueue.Supervisor,
  stratégie : :one_for_one
]

DynamicSupervisor.start_link(options)
```

Ensuite, pour démarrer un nouveau SimpleQueue dynamiquement, nous utiliserons `start_child/2` qui prend un superviseur et la spécification de l'enfant (encore une fois, `SimpleQueue` utilise `use GenServer` donc la spécification de l'enfant est déjà définie) :

```elixir
{:ok, pid} = DynamicSupervisor.start_child(SimpleQueue.Supervisor, SimpleQueue)
```

## Superviseur de tâches

Les tâches ont leur propre superviseur spécialisé, le `Task.Supervisor`.
Conçu pour les tâches créées dynamiquement, le superviseur utilise `DynamicSupervisor` sous le capot.

### Configuration

L'inclusion du `Task.Supervisor` n'est pas différente des autres superviseurs :

```elixir
children = [
  {Task.Supervisor, nom : ExampleApp.TaskSupervisor, restart : :transient}
]

{:ok, pid} = Supervisor.start_link(children, strategy : :one_for_one)
```

La principale différence entre `Supervisor` et `Task.Supervisor` est que sa stratégie de redémarrage par défaut est `:temporaire` (les tâches ne seront jamais redémarrées).

### Tâches supervisées

Avec le superviseur démarré, nous pouvons utiliser la fonction `start_child/2` pour créer une tâche supervisée :

```elixir
{:ok, pid} = Task.Supervisor.start_child(ExampleApp.TaskSupervisor, fn -> travail de fond end)
```

Si notre tâche s'arrête prématurément, elle sera redémarrée pour nous.
Cela peut être particulièrement utile lorsque l'on travaille avec des connexions entrantes ou que l'on traite du travail en arrière-plan.
