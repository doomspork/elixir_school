### Protocoles

Dans cette leçon, nous allons examiner les protocoles, ce qu'ils sont, et comment nous les utilisons dans Elixir.

## Que sont les protocoles ?
Que sont les protocoles ?
Les protocoles sont un moyen de réaliser le polymorphisme en Elixir.
Une des difficultés d'Erlang est d'étendre une API existante pour des types nouvellement définis.
Pour éviter cela, dans Elixir, la fonction est distribuée dynamiquement en fonction du type de la valeur.
Elixir est livré avec un certain nombre de protocoles intégrés, par exemple le protocole `String.Chars` est responsable de la fonction `to_string/1` que nous avons vu utilisée précédemment.
Regardons de plus près la fonction `to_string/1` avec un exemple rapide :

```elixir
iex> to_string(5)
"5"
iex> to_string(12.4)
"12.4"
iex> to_string("foo")
"foo"
```

Comme vous pouvez le voir, nous avons appelé la fonction sur plusieurs types et démontré qu'elle fonctionne sur tous.
Et si on appelait `to_string/1` sur des tuples (ou tout autre type qui n'a pas implémenté `String.Chars`) ?
Voyons cela :

```elixir
to_string({:foo})
** (Protocol.UndefinedError) protocole String.Chars non implémenté pour {:foo}
    (élixir) lib/string/chars.ex:3 : String.Chars.impl_for!/1
    (élixir) lib/string/chars.ex:17 : String.Chars.to_string/1
```

Comme vous pouvez le voir, nous obtenons une erreur de protocole car il n'y a pas d'implémentation pour les tuples.
Dans la section suivante, nous allons implémenter le protocole `String.Chars` pour les tuples.

## Implémentation d'un protocole

Nous avons vu que `to_string/1` n'a pas encore été implémenté pour les tuples, alors ajoutons-le.
Pour créer une implémentation, nous utiliserons `defimpl` avec notre protocole, et fournirons l'option `:for`, et notre type.
Voyons à quoi cela peut ressembler :

```elixir
defimpl String.Chars, for : Tuple do
  def to_string(tuple) do
    intérieur =
      tuple
      |> Tuple.to_list()
      |> Enum.map(&Kernel.to_string/1)
      |> Enum.join(", ")

    "{#{interior}}"
  fin
end
```

Si nous copions ceci dans IEx, nous devrions maintenant être capables d'appeler `to_string/1` sur un tuple sans obtenir une erreur :

```elixir
iex> to_string({3.14, "apple", :pie})
"{3.14, pomme, tarte}"
```

Nous savons comment implémenter un protocole mais comment en définir un nouveau ?
Pour notre exemple, nous allons implémenter `to_atom/1`.
Voyons comment le faire avec `defprotocol` :

```elixir
defprotocol AsAtom do
  def to_atom(données)
end

defimpl AsAtom, for: Atom do
  def to_atom(atome), do : atome
end

defimpl AsAtom, for: BitString do
  defdelegate to_atom(string), to : String
end

defimpl AsAtom, for: Liste do
  defdelegate to_atom(list), to : Liste
end

defimpl AsAtom, for: Map do
  def to_atom(map), do : List.first(Map.keys(map))
end
```

Ici, nous avons défini notre protocole et sa fonction attendue, `to_atom/1`, ainsi que des implémentations pour quelques types.
Maintenant que nous avons notre protocole, utilisons-le dans IEx :

```elixir
iex> import AsAtom
AsAtom
iex> to_atom("string")
:string
iex> to_atom(:an_atom)
:an_atom
iex> to_atom([1, 2])
:"\x01\x02"
iex> to_atom(%{foo : "bar"})
:foo
```

Il convient de noter que, bien que les structs sous-jacents soient des cartes, ils ne partagent pas les implémentations du protocole avec les cartes.
Ils ne sont pas énumérables, ils ne sont pas accessibles.

Comme nous pouvons le constater, les protocoles sont un moyen puissant de réaliser le polymorphisme.
