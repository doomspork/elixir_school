Nous avons appris à connaître les Typespecs dans la leçon précédente, ici nous allons apprendre comment exiger d'un module qu'il implémente ces spécifications.
  
En Elixir, cette fonctionnalité est désignée sous le nom de comportements.

## Usages

Parfois, vous souhaitez que des modules partagent une API publique. La solution pour cela en Elixir est le comportement.
Les comportements remplissent deux rôles principaux :

+ Définir un ensemble de fonctions qui doivent être implémentées
+ Vérifier si cet ensemble a été effectivement implémenté

Elixir inclut un certain nombre de comportements tels que `GenServer`, mais dans cette leçon nous allons nous concentrer sur la création de nos propres comportements.

## Définir un comportement

Pour mieux comprendre les comportements, implémentons-en un pour un module worker.
Ces workers devront implémenter deux fonctions : `init/1` et `perform/2`.

Pour ce faire, nous utiliserons la directive `@callback` dont la syntaxe est similaire à celle de `@spec`.
Elle définit une fonction __required__ ; pour les macros, nous pouvons utiliser `@macrocallback`.
Spécifions les fonctions `init/1` et `perform/2` pour nos workers :

```elixir
defmodule Example.Worker do
  @callback init(state :: term) :: {:ok, new_state :: term} | {:error, reason :: term}
  @callback perform(args :: term, state :: term) ::
              {:ok, result :: term, new_state :: term}
              | {:error, reason :: term, new_state :: term}
end
```

Ici, nous avons défini `init/1` comme acceptant n'importe quelle valeur et retournant un tuple de soit `{:ok, state}` soit `{:error, reason}`, c'est une initialisation assez standard.
Notre fonction `perform/2` recevra des arguments pour le travailleur ainsi que l'état que nous avons initialisé, nous nous attendons à ce que `perform/2` retourne `{:ok, result, state}` ou `{:error, reason, state}` comme les GenServers.

## Utiliser les comportements

Maintenant que nous avons défini notre comportement, nous pouvons l'utiliser pour créer une variété de modules qui partagent tous la même API publique.
Ajouter un comportement à notre module est facile avec l'attribut `@behaviour`.

En utilisant notre nouveau comportement, créons un module dont la tâche sera de télécharger un fichier distant et de l'enregistrer localement :

```elixir
defmodule Example.Downloader do
  @behaviour Example.Worker

  def init(opts), do: {:ok, opts}

  def perform(url, opts) do
    url
    |> HTTPoison.get!()
    |> Map.fetch(:body)
    |> write_file(opts[:path])
    |> respond(opts)
  end

  defp write_file(:error, _), do: {:error, :missing_body}

  defp write_file({:ok, contents}, path) do
    path
    |> Path.expand()
    |> File.write(contents)
  end

  defp respond(:ok, opts), do: {:ok, opts[:path], opts}
  defp respond({:error, reason}, opts), do: {:error, reason, opts}
end
```

Et pourquoi pas un worker qui compresse un tableau de fichiers ?  C'est également possible :

```elixir
defmodule Example.Compressor do
  @behaviour Example.Worker

  def init(opts), do: {:ok, opts}

  def perform(payload, opts) do
    payload
    |> compress
    |> respond(opts)
  end

  defp compress({name, files}), do: :zip.create(name, files)

  defp respond({:ok, path}, opts), do: {:ok, path, opts}
  defp respond({:error, reason}, opts), do: {:error, reason, opts}
end
```

Si le travail effectué est différent, l'API publique ne l'est pas, et tout code exploitant ces modules peut interagir avec eux en sachant qu'ils répondront comme prévu.
Cela nous donne la possibilité de créer un nombre illimité de travailleurs, effectuant tous des tâches différentes, mais se conformant à la même API publique.

Si nous ajoutons un comportement mais n'implémentons pas toutes les fonctions requises, un avertissement de compilation est généré.
Pour voir cela en action, modifions notre code `Example.Compressor` en supprimant la fonction `init/1` :

```elixir
defmodule Example.Compressor do
  @behaviour Example.Worker

  def perform(payload, opts) do
    payload
    |> compress
    |> respond(opts)
  end

  defp compress({name, files}), do: :zip.create(name, files)

  defp respond({:ok, path}, opts), do: {:ok, path, opts}
  defp respond({:error, reason}, opts), do: {:error, reason, opts}
end
```

Maintenant, lorsque nous compilons notre code, nous devrions voir un avertissement :

```shell
lib/example/compressor.ex:1: warning: undefined behaviour function init/1 (for behaviour Example.Worker)
Compiled lib/example/compressor.ex
```

Voilà, c'est fait ! Maintenant nous sommes prêts à construire et à partager des comportements avec d'autres.
