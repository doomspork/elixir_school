Nous avons examiné les abstractions d'Elixir pour la concurrence mais parfois nous avons besoin d'un plus grand contrôle et pour cela nous nous tournons vers les comportements OTP sur lesquels Elixir est construit.

Dans cette leçon, nous allons nous concentrer sur le plus gros morceau : GenServers.

## GenServer

Un serveur OTP est un module avec le comportement GenServer qui implémente un ensemble de callbacks.
À son niveau le plus basique, un GenServer est un processus unique qui exécute une boucle qui traite un message par itération en transmettant un état mis à jour.

Pour démontrer l'API du GenServer, nous allons mettre en œuvre une file d'attente de base pour stocker et récupérer des valeurs.

Pour lancer notre GenServer, nous devons le démarrer et gérer l'initialisation.
Dans la plupart des cas, nous voulons lier les processus, donc nous utilisons `GenServer.start_link/3`.
Nous passons le module GenServer que nous démarrons, les arguments initiaux, et un ensemble d'options GenServer.
Les arguments seront passés à `GenServer.init/1` qui définit l'état initial par sa valeur de retour.
Dans notre exemple, les arguments seront notre état initial :


```elixir
defmodule SimpleQueue do
  use GenServer

  @doc """
  Démarrer notre file d'attente et la lier.
  C'est une fonction d'aide
  """
  def start_link(state \\ []) do
    GenServer.start_link(__MODULE__, state, name: __MODULE__)
  end

   @doc """
  Rappel de GenServer.init/1
  """
  def init(state), do: {:ok, state}
end
```

### Fonctions synchrones

Il est souvent nécessaire d'interagir avec les GenServers d'une manière synchrone, en appelant une fonction et en attendant sa réponse.
Pour gérer les demandes synchrones, nous devons implémenter le callback `GenServer.handle_call/3` qui prend : la demande, le PID de l'appelant, et l'état existant ; il est censé répondre en renvoyant un tuple : `{:reply, response, state}`.

Avec le pattern matching, nous pouvons définir des callbacks pour de nombreuses requêtes et états différents.
Une liste complète des valeurs de retour acceptées se trouve dans la documentation de [`GenServer.handle_call/3`](https://hexdocs.pm/elixir/GenServer.html#c:handle_call/3).

Pour démontrer les requêtes synchrones, ajoutons la possibilité d'afficher notre file d'attente actuelle et de supprimer une valeur :

```elixir
defmodule SimpleQueue do
  use GenServer

  ### GenServer API

  @doc """
  GenServer.init/1 callback
  """
  def init(state), do: {:ok, state}

  @doc """
  GenServer.handle_call/3 callback
  """
  def handle_call(:dequeue, _from, [value | state]) do
    {:reply, value, state}
  end

  def handle_call(:dequeue, _from, []), do: {:reply, nil, []}

  def handle_call(:queue, _from, state), do: {:reply, state, state}

  ### Client API / Helper functions

  def start_link(state \\ []) do
    GenServer.start_link(__MODULE__, state, name: __MODULE__)
  end

  def queue, do: GenServer.call(__MODULE__, :queue)
  def dequeue, do: GenServer.call(__MODULE__, :dequeue)
end
```

Démarrons notre SimpleQueue et testons notre nouvelle fonctionnalité de dequeue :

```elixir
iex> SimpleQueue.start_link([1, 2, 3])
{:ok, #PID<0.90.0>}
iex> SimpleQueue.dequeue
1
iex> SimpleQueue.dequeue
2
iex> SimpleQueue.queue
[3]
```

### Fonctions asynchrones

Les requêtes asynchrones sont gérées par le rappel `handle_cast/2`.
Cela fonctionne comme `handle_call/3` mais ne reçoit pas l'appelant et n'est pas censé répondre.

Nous allons implémenter notre fonctionnalité de mise en file d'attente pour qu'elle soit asynchrone, en mettant à jour la file d'attente mais sans bloquer notre exécution en cours :

```elixir
defmodule SimpleQueue do
  use GenServer

  ### GenServer API

  @doc """
  GenServer.init/1 callback
  """
  def init(state), do: {:ok, state}

  @doc """
  GenServer.handle_call/3 callback
  """
  def handle_call(:dequeue, _from, [value | state]) do
    {:reply, value, state}
  end

  def handle_call(:dequeue, _from, []), do: {:reply, nil, []}

  def handle_call(:queue, _from, state), do: {:reply, state, state}

  @doc """
  GenServer.handle_cast/2 callback
  """
  def handle_cast({:enqueue, value}, state) do
    {:noreply, state ++ [value]}
  end

  ### Client API / Helper functions

  def start_link(state \\ []) do
    GenServer.start_link(__MODULE__, state, name: __MODULE__)
  end

  def queue, do: GenServer.call(__MODULE__, :queue)
  def enqueue(value), do: GenServer.cast(__MODULE__, {:enqueue, value})
  def dequeue, do: GenServer.call(__MODULE__, :dequeue)
end
```

Utilisons notre nouvelle fonctionnalité :

```elixir
iex> SimpleQueue.start_link([1, 2, 3])
{:ok, #PID<0.100.0>}
iex> SimpleQueue.queue
[1, 2, 3]
iex> SimpleQueue.enqueue(20)
:ok
iex> SimpleQueue.queue
[1, 2, 3, 20]
```

Pour plus d'informations, consultez la documentation officielle de [GenServer](https://hexdocs.pm/elixir/GenServer.html#content).
