### Umbrella Projects

Parfois, un projet peut devenir gros, très gros en fait.

L'outil de construction Mix nous permet de diviser notre code en plusieurs applications et de rendre nos projets Elixir plus faciles à gérer au fur et à mesure de leur croissance.

## Introduction

Pour créer un projet parapluie, nous démarrons un projet comme si nous allions démarrer un projet Mix normal mais en passant le drapeau `--umbrella`.
Pour cet exemple, nous allons créer *l'enveloppe* d'une boîte à outils d'apprentissage automatique.
Pourquoi une boîte à outils d'apprentissage automatique ? Pourquoi pas ? Elle est composée de divers algorithmes d'apprentissage et de fonctions utilitaires.

```shell
$ mix new machine_learning_toolkit --umbrella

* Création de .gitignore
* Création du fichier README.md
* création de mix.exs
* Création d'applications
* Création de config
* création de config/config.exs

Votre projet umbrella a été créé avec succès.
Dans votre projet, vous trouverez un répertoire apps/
où vous pouvez créer et héberger de nombreuses applications :

    cd machine_learning_toolkit
    cd apps
    mix new my_app

Les commandes comme "mix compile" et "mix test" lorsqu'elles sont exécutées
dans la racine du projet umbrella seront automatiquement exécutées
pour chaque application du répertoire apps/.
```

Comme vous pouvez le voir dans la commande shell, Mix a créé un petit projet squelette pour nous avec deux répertoires :

  - `apps/` - où résideront nos sous-projets (enfants)
  - `config/` - où se trouvera la configuration de notre projet parapluie.


## Projets enfants

Allons dans le répertoire `machine_learning_toolkit/apps` du projet et créons 3 applications normales en utilisant Mix comme suit :

```shell
$ mix new utilities

* Création du fichier README.md
* Création de .gitignore
* Création de mix.exs
* création de lib
* Création de lib/utilities.ex
* création de test
* création de test/test_helper.exs
* création de test/utilités_test.exs

Votre projet Mix a été créé avec succès.
Vous pouvez utiliser "mix" pour le compiler, le tester, et plus encore :

    cd utilitaires
    mix test

Lancez "mix help" pour plus de commandes.


$ mix new datasets

* Création du fichier README.md
* création de .gitignore
* création de mix.exs
* creating lib
* Création de lib/datasets.ex
* création de test
* création de test/test_helper.exs
* création de test/datasets_test.exs

Votre projet Mix a été créé avec succès.
Vous pouvez utiliser "mix" pour le compiler, le tester, et plus encore :

    cd datasets
    mix test

Lancez "mix help" pour plus de commandes.

$ mix new svm

* Création du fichier README.md
* création de .gitignore
* création de mix.exs
* Création de lib
* Création de lib/svm.ex
* création de test
* création de test/test_helper.exs
* création de test/svm_test.exs

Votre projet Mix a été créé avec succès.
Vous pouvez utiliser "mix" pour le compiler, le tester, et plus encore :

    cd svm
    mix test

Lancez "mix help" pour plus de commandes.
```

Nous devrions maintenant avoir un arbre de projet comme celui-ci :

```shell
$ tree
.
├── README.md
├─── apps
│ ├─── ensembles de données
│ │ ├── README.md
│ │ ├─── lib
│ │ │ └─── datasets.ex
│ │ ├─── mix.exs
│ │ └─── test
│ │ ├─── datasets_test.exs
│ │ └─── test_helper.exs
│ ├─── svm
│ │ ├─── README.md
│ │ ├─── lib
│ │ │ └─── svm.ex
│ │ ├─── mix.exs
│ │ └─── test
│ │ ├─── svm_test.exs
│ │ └─── test_helper.exs
│ └─── utilitaires
│ ├─── README.md
│ ├─── lib
│ │ └─── utilities.ex
│ ├─── mix.exs
│ └─── test
│ ├─── test_helper.exs
│ └─── utilitaires_test.exs
├─── config
│ └─── config.exs
└─── mix.exs
```

Si nous revenons à la racine du projet parapluie, nous pouvons voir que nous pouvons appeler toutes les commandes typiques telles que compile.
Comme les sous-projets sont juste des applications normales, vous pouvez changer dans leurs répertoires et faire toutes les mêmes choses comme d'habitude que Mix vous permet de faire.

```bash
$ mix compile

==> svm
Compilé lib/svm.ex
Application svm générée

==> datasets
Compilé lib/datasets.ex
Application datasets générée

==> utilitaires
Compilé lib/utilities.ex
Application utilitaires générée

List.Chars consolidée
Collectable consolidé
String.Chars consolidé
Enumérable consolidé
IEx.Info consolidé
Inspecter consolidé
```

## IEx

Vous pouvez penser que l'interaction avec les applications serait un peu différente dans un projet parapluie.
Eh bien, croyez-le ou non, vous auriez tort ! Si nous changeons de répertoire dans le répertoire de premier niveau, et que nous lançons IEx avec la commande `iex -S mix`, nous pouvons interagir avec tous les projets normalement.
Modifions le contenu de `apps/datasets/lib/datasets.ex` pour cet exemple simple.

```elixir
defmodule Datasets do
  def hello do
    IO.puts("Bonjour, je suis le datasets")
  end
end
```

```shell
$ iex -S mix
Erlang/OTP {{ site.erlang.OTP }} [erts-{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

==> datasets
Compilé lib/datasets.ex
Liste consolidée.chars
Collectable consolidé
String.Chars consolidé
Enumérable consolidé
IEx.Info consolidé
Inspecter consolidé
Elixir interactif ({{ site.elixir.version }}) - appuyez sur Ctrl+C pour sortir (tapez h() ENTER pour obtenir de l'aide)

iex> Datasets.hello
Bonjour, je suis le datasets
:ok
```
