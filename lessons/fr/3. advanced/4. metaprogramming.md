La métaprogrammation est le processus qui consiste à utiliser du code pour écrire du code.
 
Dans Elixir, cela nous donne la possibilité d'étendre le langage pour l'adapter à nos besoins et de modifier dynamiquement le code.

Nous allons commencer par examiner comment Elixir est représenté sous le capot, puis comment le modifier, et enfin nous pouvons utiliser ces connaissances pour l'étendre.

Un mot d'avertissement :  La métaprogrammation est délicate et ne doit être utilisée que si nécessaire.

Une utilisation excessive conduira presque certainement à un code complexe, difficile à comprendre et à déboguer.

## Citation

La première étape de la métaprogrammation consiste à comprendre comment les expressions sont représentées.
En Elixir, l'arbre syntaxique abstrait (AST), la représentation interne de notre code, est composé de tuples.
Ces tuples contiennent trois parties : le nom de la fonction, les métadonnées et les arguments de la fonction.

Afin de voir ces structures internes, Elixir nous fournit la fonction `quote/2`.
En utilisant `quote/2`, nous pouvons convertir le code Elixir en sa représentation sous-jacente :

```elixir
iex> quote do: 42
42
iex> quote do: "Hello"
"Hello"
iex> quote do: :world
:world
iex> quote do: 1 + 2
{:+, [context: Elixir, import: Kernel], [1, 2]}
iex> quote do: if value, do: "True", else: "False"
{:if, [context: Elixir, import: Kernel],
 [{:value, [], Elixir}, [do: "True", else: "False"]]}
```

Vous avez remarqué que les trois premiers ne renvoient pas de tuples ? Il y a cinq littéraux qui se retournent eux-mêmes lorsqu'ils sont cités :

```elixir
iex> :atom
:atom
iex> "string"
"string"
iex> 1 # All numbers
1
iex> [1, 2] # Lists
[1, 2]
iex> {"hello", :world} # 2 element tuples
{"hello", :world}
```

## Unquote

Maintenant que nous pouvons récupérer la structure interne de notre code, comment la modifier ? Pour injecter un nouveau code ou de nouvelles valeurs, nous utilisons `unquote/1`.
Lorsque nous dé-citons une expression, elle sera évaluée et injectée dans l'AST.
Pour démontrer `unquote/1`, regardons quelques exemples :

```elixir
iex> denominator = 2
2
iex> quote do: divide(42, denominator)
{:divide, [], [42, {:denominator, [], Elixir}]}
iex> quote do: divide(42, unquote(denominator))
{:divide, [], [42, 2]}
```

Dans le premier exemple, notre variable `dénominateur` est citée, donc l'AST résultant inclut un tuple pour accéder à la variable.
Dans l'exemple `unquote/1`, le code résultant inclut la valeur de `denominator` à la place.

## Macros

Une fois que nous avons compris `quote/2` et `unquote/1`, nous sommes prêts à plonger dans les macros.
Il est important de se rappeler que les macros, comme toute métaprogrammation, doivent être utilisées avec parcimonie.

En termes simples, les macros sont des fonctions spéciales conçues pour renvoyer une expression entre guillemets qui sera insérée dans le code de notre application.
Imaginez que la macro soit remplacée par l'expression citée plutôt que d'être appelée comme une fonction.
Avec les macros, nous avons tout ce qu'il faut pour étendre Elixir et ajouter dynamiquement du code à nos applications.

Nous commençons par définir une macro à l'aide de `defmacro/2` qui, comme une grande partie d'Elixir, est lui-même une macro (laissez-vous guider).
A titre d'exemple, nous allons implémenter `unless` comme une macro.
Rappelez-vous que notre macro doit retourner une expression entre guillemets :


```elixir
defmodule OurMacro do
  defmacro unless(expr, do: block) do
    quote do
      if !unquote(expr), do: unquote(block)
    end
  end
end
```

Requérons notre module et faisons tourner notre macro :

```elixir
iex> require OurMacro
nil
iex> OurMacro.unless true, do: "Hi"
nil
iex> OurMacro.unless false, do: "Hi"
"Hi"
```

Comme les macros remplacent le code dans notre application, nous pouvons contrôler quand et quoi est compilé.
Un exemple de ceci peut être trouvé dans le module `Logger`.
Lorsque la journalisation est désactivée, aucun code n'est injecté et l'application résultante ne contient aucune référence ou appel de fonction à la journalisation.
C'est différent des autres langages où il y a toujours l'overhead d'un appel de fonction même si l'implémentation est NOP.

Pour démontrer cela, nous allons créer un simple logger qui peut être activé ou désactivé :

```elixir
defmodule Logger do
  defmacro log(msg) do
    if Application.get_env(:logger, :enabled) do
      quote do
        IO.puts("Logged message: #{unquote(msg)}")
      end
    end
  end
end

defmodule Example do
  require Logger

  def test do
    Logger.log("This is a log message")
  end
end
```

Avec la journalisation activée, notre fonction `test` donnerait un code ressemblant à quelque chose comme ceci :

```elixir
def test do
  IO.puts("Logged message: #{"This is a log message"}")
end
```

Si nous désactivons la journalisation, le code résultant serait :

```elixir
def test do
end
```

## Débogage

Ok, maintenant nous savons comment utiliser `quote/2`, `unquote/1` et écrire des macros.
Mais que faire si vous avez un gros morceau de code cité et que vous voulez le comprendre ? Dans ce cas, vous pouvez utiliser `Macro.to_string/2`.
Jetez un coup d'oeil à cet exemple :

```elixir
iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))
"foo.bar(1, 2, 3)"
```

Et quand vous voulez regarder le code généré par les macros, vous pouvez les combiner avec `Macro.expand/2` et `Macro.expand_once/2`, ces fonctions développent les macros dans le code cité qui leur est donné.
La première peut l'étendre plusieurs fois, tandis que la seconde - une seule fois.
Par exemple, modifions l'exemple `unless` de la section précédente :

```elixir
defmodule OurMacro do
  defmacro unless(expr, do: block) do
    quote do
      if !unquote(expr), do: unquote(block)
    end
  end
end

require OurMacro

quoted =
  quote do
    OurMacro.unless(true, do: "Hi")
  end
```

```elixir
iex> quoted |> Macro.expand_once(__ENV__) |> Macro.to_string |> IO.puts
if(!true) do
  "Hi"
end
```

Si nous exécutons le même code avec `Macro.expand/2`, c'est intriguant :

```elixir
iex> quoted |> Macro.expand(__ENV__) |> Macro.to_string |> IO.puts
case(!true) do
  x when x in [false, nil] ->
    nil
  _ ->
    "Hi"
end
```

Vous vous souvenez peut-être que nous avons mentionné que `if` est une macro en Elixir, ici nous la voyons développée dans l'instruction sous-jacente `case`.

### Macros privées

Bien que ce ne soit pas aussi courant, Elixir supporte les macros privées.
Une macro privée est définie avec `defmacrop` et ne peut être appelée que depuis le module dans lequel elle a été définie.
Les macros privées doivent être définies avant le code qui les invoque.

### Hygiène des macros

La façon dont les macros interagissent avec le contexte de l'appelant lorsqu'elles sont étendues est connue sous le nom d'hygiène des macros.
Par défaut, les macros dans Elixir sont hygiéniques et n'entrent pas en conflit avec notre contexte :

```elixir
defmodule Example do
  defmacro hygienic do
    quote do: val = -1
  end
end

iex> require Example
nil
iex> val = 42
42
iex> Example.hygienic
-1
iex> val
42
```

Et si nous voulions manipuler la valeur de `val` ? Pour marquer une variable comme non hygiénique, nous pouvons utiliser `var!/2`.
Mettons à jour notre exemple pour inclure une autre macro utilisant `var!/2` :

```elixir
defmodule Example do
  defmacro hygienic do
    quote do: val = -1
  end

  defmacro unhygienic do
    quote do: var!(val) = -1
  end
end
```

Comparons comment ils interagissent avec notre contexte :

```elixir
iex> require Example
nil
iex> val = 42
42
iex> Example.hygienic
-1
iex> val
42
iex> Example.unhygienic
-1
iex> val
-1
```

En incluant `var!/2` dans notre macro, nous avons manipulé la valeur de `val` sans la passer dans notre macro.
L'utilisation de macros non hygiéniques doit être réduite au minimum.
En incluant `var!/2`, nous augmentons le risque d'un conflit de résolution de variable.

### Liant

Nous avons déjà couvert l'utilité de `unquote/1`, mais il existe un autre moyen d'injecter des valeurs dans notre code : le binding.
Avec le binding de variables, nous pouvons inclure plusieurs variables dans notre macro et nous assurer qu'elles ne seront dé-citées qu'une seule fois, évitant ainsi les réévaluations accidentelles.
Pour utiliser des variables liées, nous devons passer une liste de mots-clés à l'option `bind_quoted` de `quote/2`.

Pour voir les avantages de l'option `bind_quoted` et pour démontrer le problème de la réévaluation, prenons un exemple.
Nous pouvons commencer par créer une macro qui sort simplement l'expression deux fois :

```elixir
defmodule Example do
  defmacro double_puts(expr) do
    quote do
      IO.puts(unquote(expr))
      IO.puts(unquote(expr))
    end
  end
end
```

Nous allons essayer notre nouvelle macro en lui passant l'heure actuelle du système.
Nous devrions nous attendre à la voir sortir deux fois :

```elixir
iex> Example.double_puts(:os.system_time)
1450475941851668000
1450475941851733000
```

Les heures sont différentes ! Que s'est-il passé ? L'utilisation de `unquote/1` sur la même expression plusieurs fois entraîne une réévaluation et cela peut avoir des conséquences inattendues.
Mettons à jour l'exemple pour utiliser `bind_quoted` et voyons ce que nous obtenons :

```elixir
defmodule Example do
  defmacro double_puts(expr) do
    quote bind_quoted: [expr: expr] do
      IO.puts(expr)
      IO.puts(expr)
    end
  end
end

iex> require Example
nil
iex> Example.double_puts(:os.system_time)
1450476083466500000
1450476083466500000
```

Avec `bind_quoted`, nous obtenons le résultat attendu : la même heure imprimée deux fois.

Maintenant que nous avons couvert `quote/2`, `unquote/1`, et `defmacro/2`, nous avons tous les outils nécessaires pour étendre Elixir selon nos besoins.
