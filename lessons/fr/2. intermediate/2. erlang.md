L'un des avantages supplémentaires de la construction au-dessus de la VM Erlang (BEAM) est la pléthore de bibliothèques existantes à notre disposition.

L'interopérabilité nous permet de tirer parti de ces bibliothèques et de la bibliothèque standard Erlang à partir de notre code Elixir.

Dans cette leçon, nous verrons comment accéder aux fonctionnalités de la bibliothèque standard et aux paquets Erlang tiers.

## Bibliothèque standard

La vaste bibliothèque standard d'Erlang est accessible depuis n'importe quel code Elixir de notre application.
Les modules Erlang sont représentés par des atomes en minuscules tels que `:os` et `:timer`.

Utilisons `:timer.tc` pour chronométrer l'exécution d'une fonction donnée :

```elixir
defmodule Exemple do
  def timed(fun, args) do
    {time, résultat} = :timer.tc(fun, args)
    IO.puts("Temps : #{temps} μs")
    IO.puts("Résultat : #{résultat}")
  end
end

iex> Exemple.timed(fn (n) -> (n * n) * n end, [100])
Temps : 8 μs
Résultat : 1000000
```

Pour une liste complète des modules disponibles, voir le [Manuel de référence Erlang](http://erlang.org/doc/apps/stdlib/).

## Paquets Erlang

Dans une leçon précédente, nous avons couvert le mélange et la gestion de nos dépendances.
L'inclusion de bibliothèques Erlang fonctionne de la même manière.
Dans le cas où la bibliothèque Erlang n'a pas été poussée vers [Hex](https://hex.pm), vous pouvez vous référer au dépôt git à la place :

```elixir
def deps do
  [{:png, github : "yuce/png"}]]
end
```

Maintenant, nous pouvons accéder à notre bibliothèque Erlang :

```elixir
png =
  :png.create(%{:size => {30, 30}, :mode => {:indexed, 8}, :file => fichier, :palette => palette}))
```

## Différences notables

Maintenant que nous savons comment utiliser Erlang, nous devrions couvrir certains des problèmes liés à l'interopérabilité d'Erlang.

### Atomes

Les atomes Erlang ressemblent beaucoup à leurs homologues Elixir sans les deux points (`:`).
Ils sont représentés par des chaînes de caractères minuscules et des caractères de soulignement :

Elixir :

```elixir
:exemple
```

Erlang :

```erlang
exemple.
```

### Chaînes de caractères

En Elixir, lorsque nous parlons de chaînes de caractères, nous faisons référence à des binaires encodés en UTF-8.
En Erlang, les chaînes de caractères utilisent toujours les guillemets doubles mais se réfèrent à des listes de caractères :

Elixir :

```elixir
iex> is_list('Exemple')
true
iex> is_list("Exemple")
false
iex> is_binary("Exemple")
true
iex> <<"Exemple">> === "Exemple
true
```

Erlang :

```erlang
1> is_list('Exemple').
false
2> is_list("Exemple").
true
3> is_binary("Exemple").
false
4> is_binary(<<"Exemple">>).
true
```

Il est important de noter que de nombreuses bibliothèques Erlang plus anciennes peuvent ne pas supporter les binaires, nous devons donc convertir les chaînes Elixir en listes de caractères.
Heureusement, cela est facile à réaliser avec la fonction `to_charlist/1` :

```elixir
iex> :string.words("Hello World")
** (FunctionClauseError) pas de clause de fonction correspondante dans :string.strip_left/2

    Les arguments suivants ont été donnés à :string.strip_left/2 :

        # 1
        "Hello World"

        # 2
        32

    (stdlib) string.erl:1661 : :string.strip_left/2
    (stdlib) string.erl:1659 : :string.strip/3
    (stdlib) string.erl:1597 : :string.words/2

iex> "Hello World" |> to_charlist() |> :string.words
2
```

### Variables

En Erlang, les variables commencent par une lettre majuscule et la reliance n'est pas autorisée.

Elixir :

```elixir
iex> x = 10
10

iex> x = 20
20

iex> x1 = x + 10
30
```

Erlang :

```erlang
1> X = 10.
10

2> X = 20.
** exception error : no match of right hand side value 20

3> X1 = X + 10.
20
```

Voilà, c'est fait ! L'exploitation d'Erlang au sein de nos applications Elixir est facile et double efficacement le nombre de bibliothèques à notre disposition.
