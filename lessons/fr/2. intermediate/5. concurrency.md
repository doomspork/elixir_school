### Concurrence

L'un des arguments de vente d'Elixir est son support de la concurrence.

Grâce à la VM Erlang (BEAM), la concurrence dans Elixir est plus facile que prévu.

Le modèle de concurrence repose sur les acteurs, un processus contenu qui communique avec d'autres processus par le biais du passage de messages.

Dans cette leçon, nous examinerons les modules de concurrence fournis avec Elixir.
Dans le chapitre suivant, nous couvrirons les comportements OTP qui les mettent en œuvre.

## Processus

Les processus dans la VM Erlang sont légers et s'exécutent sur tous les processeurs.
Bien qu'ils puissent ressembler à des threads natifs, ils sont plus simples et il n'est pas rare d'avoir des milliers de processus concurrents dans une application Elixir.

La façon la plus simple de créer un nouveau processus est `spawn`, qui prend une fonction anonyme ou nommée.
Lorsque nous créons un nouveau processus, il retourne un _Process Identifier_, ou PID, pour l'identifier de manière unique dans notre application.

Pour commencer, nous allons créer un module et définir une fonction que nous souhaitons exécuter :

```elixir
defmodule Exemple do
  def add(a, b) do
    IO.puts(a + b)
  end
end

iex> Exemple.add(2, 3)
5
:ok
```

Pour évaluer la fonction de manière asynchrone, nous utilisons `spawn/3` :

```elixir
iex> spawn(Exemple, :add, [2, 3])
5
#PID<0.80.0>
```

### Passage de messages

Pour communiquer, les processus s'appuient sur le passage de messages.
Il y a deux composantes principales à cela : `send/2` et `receive`.
La fonction `send/2` nous permet d'envoyer des messages à des PIDs.
Pour écouter, nous utilisons `receive` pour faire correspondre les messages.
Si aucune correspondance n'est trouvée, l'exécution continue sans interruption.

```elixir
defmodule Exemple do
  def listen do
    receive do
      {:ok, "hello"} -> IO.puts("Monde")
    end

    listen()
  end
end

iex> pid = spawn(Exemple, :listen, [])
#PID<0.108.0>

iex> send pid, {:ok, "hello"}
Monde
{:ok, "hello"}

iex> send pid, :ok
:ok
```

Vous pouvez remarquer que la fonction `listen/0` est récursive, cela permet à notre processus de gérer plusieurs messages.
Sans récursion, notre processus se terminerait après avoir traité le premier message.

### Liaison de processus

Un problème avec `spawn` est de savoir quand un processus s'arrête.
Pour cela, nous devons lier nos processus en utilisant `spawn_link`.
Deux processus liés recevront des notifications de sortie l'un de l'autre :

```elixir
defmodule Exemple do
  def explode, do : exit(:kaboom)
end

iex> spawn(Exemple, :explode, [])
#PID<0.66.0>

iex> spawn_link(Exemple, :explode, [])
** (EXIT from #PID<0.57.0>) Le processus évaluateur s'est terminé avec la raison suivante : :kaboom
```

Parfois, nous ne voulons pas que notre processus lié fasse planter le processus actuel.
Pour cela, nous devons piéger les sorties en utilisant `Process.flag/2`.
Il utilise la fonction [process_flag/2](http://erlang.org/doc/man/erlang.html#process_flag-2) d'erlang pour le drapeau `trap_exit`. Lorsque l'on piège les sorties (`trap_exit` est mis à `true`), les signaux de sortie seront reçus sous forme de message tuple : `{:EXIT, from_pid, reason}`.

```elixir
defmodule Exemple do
  def explode, do : exit(:kaboom)

  def run do
    Process.flag(:trap_exit, true)
    spawn_link(Exemple, :explode, [])

    recevoir do
      {:EXIT, _from_pid, reason} -> IO.puts("Exit reason : #{reason}")
    end
  end
end

iex> Exemple.run
Raison de la sortie : kaboom
:ok
```

### Surveillance des processus

Et si on ne veut pas lier deux processus mais être quand même tenu au courant ? Pour cela, nous pouvons utiliser la surveillance de processus avec `spawn_monitor`.
Lorsque nous surveillons un processus, nous recevons un message si le processus s'écrase sans que notre processus actuel s'écrase ou que nous ayons besoin de piéger explicitement les sorties.

```elixir
defmodule Exemple do
  def explode, do : exit(:kaboom)

  def run do
    spawn_monitor(Exemple, :explode, [])

    receive do
      {:DOWN, _ref, :process, _from_pid, reason} -> IO.puts("Exit reason : #{reason}")
    end
  end
end

iex> Exemple.run
Raison de la sortie : kaboom
:ok
```

## Agents

Les agents sont une abstraction autour des processus d'arrière-plan qui maintiennent l'état.
Nous pouvons y accéder depuis d'autres processus de notre application et de notre nœud.
L'état de notre agent est défini par la valeur de retour de notre fonction :

```elixir
iex> {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
{:ok, #PID<0.65.0>}

iex> Agent.update(agent, fn (state) -> state ++ [4, 5] end)
:ok

iex> Agent.get(agent, &(&1))
[1, 2, 3, 4, 5]
```

Lorsque nous nommons un agent, nous pouvons le désigner par ce nom au lieu de son PID :

```elixir
iex> Agent.start_link(fn -> [1, 2, 3] end, name : Numbers)
{:ok, #PID<0.74.0>}

iex> Agent.get(Nombres, &(&1))
[1, 2, 3]
```

## Tâches

Les tâches permettent d'exécuter une fonction en arrière-plan et de récupérer sa valeur de retour ultérieurement.
Elles peuvent être particulièrement utiles pour traiter des opérations coûteuses sans bloquer l'exécution de l'application.

```elixir
defmodule Exemple do
  def double(x) do
    :timer.sleep(2000)
    x * 2
  end
end

iex> task = Task.async(Exemple, :double, [2000])
%Task{
  propriétaire : #PID<0.105.0>,
  pid : #PID<0.114.0>,
  ref : #Reference<0.2418076177.4129030147.64217>
}

# Faire un travail

iex> Task.await(tâche)
4000
```
