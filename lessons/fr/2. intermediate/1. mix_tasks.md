Création de tâches Mix personnalisées pour vos projets Elixir.

## Introduction

Il n'est pas rare de vouloir étendre les fonctionnalités de vos applications Elixir en ajoutant des tâches Mix personnalisées.
Avant d'apprendre à créer des tâches Mix spécifiques pour nos projets, examinons-en une qui existe déjà :

```shell
$ mix phx.new mon_phoenix_app

* création de mon_phoenix_app/config/config.exs
* création de mon_phoenix_app/config/dev.exs
* création de mon_phoenix_app/config/prod.exs
* création de ma_phoenix_app/config/prod.secret.exs
* création de mon_phoenix_app/config/test.exs
* création de mon_phoenix_app/lib/mon_phoenix_app.exs
* création de mon_phoenix_app/lib/mon_phoenix_app/endpoint.exs
* création de mon_phoenix_app/test/views/error_view_test.exs
...
```

Comme nous pouvons le voir dans la commande shell ci-dessus, The Phoenix Framework dispose d'une tâche Mix personnalisée pour générer un nouveau projet.
Et si nous pouvions créer quelque chose de similaire pour notre projet ? Eh bien, la bonne nouvelle est que nous le pouvons, et Elixir nous facilite la tâche.

## Configuration

Configurons une application Mix de base.

```shell
$ mix new hello

* Création du fichier README.md
* Création du fichier .formatter.exs
* Création de .gitignore
* création de mix.exs
* creating lib
* creating lib/hello.ex
* creating test
* création de test/test_helper.exs
* création de test/hello_test.exs

Votre projet Mix a été créé avec succès.
Vous pouvez utiliser "mix" pour le compiler, le tester, et plus encore :

cd hello
mix test

Lancez "mix help" pour plus de commandes.
```

Maintenant, dans notre fichier **lib/hello.ex** que Mix a généré pour nous, créons une fonction simple qui produira "Hello, World !"

```elixir
defmodule Hello do
  @doc """
  Affiche "Hello, World!`` à chaque fois.
  """
  def say do
    IO.puts("Bonjour, monde !")
  end
end
```

## Tâche de mixage personnalisée

Créons notre tâche Mix personnalisée.
Créez un nouveau répertoire et un fichier **hello/lib/mix/tasks/hello.ex**.
Dans ce fichier, insérons ces 7 lignes d'Elixir.

```elixir
defmodule Mix.Tasks.Hello do
  @moduledoc "La tâche Mix hello : `mix help hello`"
  use Mix.Task

  @shortdoc "Appelle simplement la fonction Hello.say/0."
  def run(_) do
    # appel de notre fonction Hello.say() de tout à l'heure
    Hello.say()
  end
end
```

Remarquez comment nous commençons l'instruction defmodule avec `Mix.Tasks` et le nom que nous voulons appeler depuis la ligne de commande.
Sur la deuxième ligne, nous introduisons le `use Mix.Task` qui amène le comportement de `Mix.Task` dans l'espace de nom.
Nous déclarons ensuite une fonction run qui ignore pour l'instant tout argument.
Dans cette fonction, nous appelons notre module `Hello` et la fonction `say`.

## Chargement de votre application

Mix ne démarre pas automatiquement notre application ou l'une de ses dépendances, ce qui est bien pour la plupart des cas d'utilisation de Mix, mais que faire si nous devons utiliser Ecto et interagir avec une base de données ? Dans ce cas, nous devons nous assurer que l'application derrière Ecto.Repo a démarré. Il y a deux façons de gérer cela : démarrer explicitement une application ou démarrer notre application qui à son tour démarrera les autres.

Voyons comment nous pouvons mettre à jour notre tâche Mix pour démarrer notre application et ses dépendances :

```elixir
defmodule Mix.Tasks.Hello do
  @moduledoc "La tâche Mix hello : `mix help hello`"
  use Mix.Task

  @shortdoc "Appelle simplement la fonction Hello.say/0."
  def run(_) do
    # Ceci va démarrer notre application
    Mix.Task.run("app.start")

    Hello.say()
  end
end
```

## Tâches de mélange en action

Vérifions notre tâche de mixage.
Tant que nous sommes dans le répertoire, cela devrait fonctionner.
Depuis la ligne de commande, exécutez `mix hello`, et nous devrions voir ce qui suit :

```shell
$ mix hello
Bonjour le monde !
```

Mix est assez convivial par défaut.
Il sait que tout le monde peut faire une erreur d'orthographe de temps en temps, donc il utilise une technique appelée correspondance floue des chaînes de caractères pour faire des recommandations :

```shell
$ mix hell
** (Mix) La tâche "hell" n'a pas pu être trouvée. Voulez-vous dire "hello" ?
```

Avez-vous également remarqué que nous avons introduit un nouvel attribut de module, `@shortdoc` ? Cela s'avère pratique lors de l'envoi de notre application, par exemple lorsqu'un utilisateur exécute la commande `mix help` depuis le terminal.

```shell
$ mix help

mix app.start # Démarre toutes les applications enregistrées
...
mix hello # Appelle simplement la fonction Hello.say/0.
...
```

Note : Notre code doit être compilé avant que les nouvelles tâches n'apparaissent dans la sortie `mix help`.
Nous pouvons le faire soit en exécutant directement `mix compile`, soit en exécutant notre tâche comme nous l'avons fait avec `mix hello`, ce qui déclenchera la compilation pour nous.
