### Gestion des erreurs
Bien qu'il soit plus courant de retourner le tuple `{:error, reason}`, Elixir supporte les exceptions et dans cette leçon, nous allons voir comment gérer les erreurs et les différents mécanismes à notre disposition.

En général, la convention dans Elixir est de créer une fonction (`exemple/1`) qui renvoie `{:ok, result}` et `{:error, reason}` et une fonction séparée (`exemple!/1`) qui renvoie le `resultat` ou soulève une erreur.

Cette leçon se concentre sur l'interaction avec cette dernière.

## Conventions générales

Pour l'instant, la communauté Elixir a établi certaines conventions concernant le retour des erreurs :

* Pour les erreurs qui font partie du fonctionnement normal d'une fonction (par exemple, un utilisateur a saisi un mauvais type de date), une fonction renvoie `{:ok, result}` et `{:error, reason}` en conséquence.
* Pour les erreurs qui ne font pas partie des opérations normales (par exemple, l'impossibilité d'analyser les données de configuration), vous lancez une exception.

Nous traitons généralement les erreurs de flux standard par [Pattern Matching](/fr/lessons/basics/pattern_matching), mais dans cette leçon, nous nous concentrons sur le deuxième cas - sur les exceptions.

Souvent, dans les API publiques, vous pouvez également trouver une deuxième version de la fonction avec un ! (exemple!/1) qui renvoie le résultat non enveloppé ou soulève une erreur.

## Gestion des erreurs

Avant de pouvoir gérer les erreurs, nous devons les créer et la façon la plus simple de le faire est avec `raise/1` :

```elixir
iex> raise "Oh no !"
** (RuntimeError) Oh non !
```

Si nous voulons spécifier le type et le message, nous devons utiliser `raise/2` :

```elixir
iex> raise ArgumentError, message : "la valeur de l'argument est invalide"
** (ArgumentError) la valeur de l'argument n'est pas valide
```

Lorsque l'on sait qu'une erreur peut se produire, on peut la traiter en utilisant les fonctions `try/rescue` et la correspondance de motifs :

```elixir
iex> try do
...> raise "Oh no !"
...> rescue
...> e in RuntimeError -> IO.puts("Une erreur est survenue : " <> e.message)
...> end
Une erreur s'est produite : Oh non !
:ok
```

Il est possible de faire correspondre plusieurs erreurs dans un seul sauvetage :

```elixir
essayer faire
  opts
  |> Mot-clé.fetch !(:fichier_source)
  |> Fichier.read !()
récupérer
  e in KeyError -> IO.puts("option :source_file manquante")
  e in File.Error -> IO.puts("impossible de lire le fichier source")
end
```

## Après

Parfois, il peut être nécessaire d'effectuer une action après notre `try/rescue` indépendamment de l'erreur.
Pour cela, nous avons `try/after`.
Si vous êtes familier avec Ruby, cela ressemble à `begin/rescue/ensure` ou en Java `try/catch/finally` :

```elixir
iex> try do
...> raise "Oh no !"
...> rescue
...> e dans RuntimeError -> IO.puts("Une erreur est survenue : " <> e.message)
...> après
...> IO.puts "La fin !"
...> end
Une erreur s'est produite : Oh non !
La fin !
:ok
```

Ceci est le plus souvent utilisé avec des fichiers ou des connexions qui doivent être fermés :

```elixir
{:ok, fichier} = File.open("exemple.json")

essayez de faire
  # Faire un travail dangereux
après
  File.close(file)
end
```

## Nouvelles erreurs

Bien qu'Elixir inclue un certain nombre de types d'erreurs intégrés comme `RuntimeError`, nous conservons la possibilité de créer nos propres erreurs si nous avons besoin de quelque chose de spécifique.
La création d'une nouvelle erreur est facile avec la macro `defexception/1` qui accepte commodément l'option `:message` pour définir un message d'erreur par défaut :

```elixir
defmodule ExempleErreur do
  defexception message : "un exemple d'erreur s'est produit"
end
```

Essayons notre nouvelle erreur :

```elixir
iex> try do
...> raise ExempleErreur
...> rescue
...> e dans ErreurExemple -> e
...> end
%ExampleError{message : "une erreur d'exemple s'est produite"}
```

## Lancer

Un autre mécanisme pour travailler avec les erreurs dans Elixir est `throw` et `catch`.
En pratique, ces fonctions n'apparaissent que très rarement dans le code Elixir récent, mais il est néanmoins important de les connaître et de les comprendre.

La fonction `throw/1` nous donne la possibilité de quitter l'exécution avec une valeur spécifique que nous pouvons `catch` et utiliser :

```elixir
iex> try do
...> for x <- 0..10 do
...> si x == 5, do : throw(x)
...> IO.puts(x)
...> end
...> catch
...> x -> "Caught : #{x}"
...> end
0
1
2
3
4
"Attrapé : 5"
```

Comme mentionné, `throw/catch` sont assez rares et existent typiquement comme palliatifs lorsque les bibliothèques ne fournissent pas d'API adéquates.

## Sortie

Le dernier mécanisme d'erreur qu'Elixir nous fournit est `exit`.
Les signaux de sortie se produisent lorsqu'un processus meurt et sont une partie importante de la tolérance aux pannes d'Elixir.

Pour sortir explicitement, nous pouvons utiliser `exit/1` :

```elixir
iex> spawn_link fn -> exit("oh no") end
** (EXIT from #PID<0.101.0>) Le processus évaluateur s'est terminé avec la raison : "oh no".
```

Bien qu'il soit possible d'attraper une sortie avec `try/catch`, cela est _extrêmement_ rare.
Dans presque tous les cas, il est avantageux de laisser le superviseur gérer la sortie du processus :

```elixir
iex> try do
...> exit "oh no !"
...> catch
...> :exit, _ -> "exit blocked" (sortie bloquée)
...> end
"sortie bloquée"
```
